<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/04/02/hello-world/"/>
      <url>/2023/04/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>图算法分类、Java模板及例题</title>
      <link href="/2023/04/02/1004-graph/"/>
      <url>/2023/04/02/1004-graph/</url>
      
        <content type="html"><![CDATA[<h1 id="图算法分类、Java模板及例题"><a href="#图算法分类、Java模板及例题" class="headerlink" title="图算法分类、Java模板及例题"></a>图算法分类、Java模板及例题</h1><h2 id="图算法分类"><a href="#图算法分类" class="headerlink" title="图算法分类"></a>图算法分类</h2><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><ol><li>假设图有n个节点，编号为1~n-1；</li><li>二维数组xx记录n条边，其中xx[i] = [ai, bi] ，表示ai指向bi（有向图）或ai和bi之间有一条边相连（无向图）。</li></ol><h2 id="判断环"><a href="#判断环" class="headerlink" title="判断环"></a>判断环</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>一个节点在一轮dfs中被遍历了不止一次，说明存在环；</li><li>若要求按序输出所有节点（拓扑的DFS实现），需要第一次遍历到节点时压栈，遍历完所有节点后，弹栈输出即可。</li></ul><h3 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h3><pre><code>class Solution {    int[] visited; //0:未被遍历到 1:之前访问过，但不是在本轮被访问的 2:在本轮被访问过    public boolean canFinish(int n, int[][] prerequisites) {        if(n == 0 || prerequisites.length == 0) return true;        // 1.根据关系建立邻接表        List&lt;List&lt;Integer&gt;&gt; adjs = new ArrayList&lt;&gt;();        for(int i = 0; i &lt; n; i ++){            adjs.add(new ArrayList&lt;&gt;());        }        for(int[] prerequisite : prerequisites){            adjs.get(prerequisite[1]).add(prerequisite[0]);        }        // 2.dfs遍历        visited = new int[n];        for(int i = 0; i &lt; n; i ++){            if(visited[i] == 0){                 //节点i未被遍历过                if(dfs(adjs, i)){                    //本轮遍历中存在环                    return false;                }            }        }        return true;    }    // 若本轮遍历存在环则返回true    private boolean dfs(List&lt;List&lt;Integer&gt;&gt; adjs, int cur){        if(visited[cur] == 1){            // 之前访问过，但不是在本轮被访问的            return false;        }else if(visited[cur] == 2){            // 在本轮被访问过，存在环            return true;        }        // 此时visited[cur] = 0        // 1.将visited[cur]标记为2        visited[cur] = 2;        // 2.对其邻接节点进行遍历        for(int next : adjs.get(cur)){            if(dfs(adjs, next)){                // 发现环                return true;            }        }        // 3.遍历结束，未发现环，设置visited[cur] = 1        visited[cur] = 1;        return false;    }}</code></pre><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>时间：O(n+e)<br>空间：O(n+e) (邻接表)</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><a href="https://leetcode.cn/problems/course-schedule/">lc207课程表</a></p><h3 id="BFS（拓扑排序）"><a href="#BFS（拓扑排序）" class="headerlink" title="BFS（拓扑排序）"></a>BFS（拓扑排序）</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>拓扑排序</li></ul><h4 id="算法模板-1"><a href="#算法模板-1" class="headerlink" title="算法模板"></a>算法模板</h4><pre><code>class Solution {    public boolean canFinish(int n, int[][] prerequisites) {        if(n == 0 || prerequisites.length == 0) return true;        // 1.根据关系建立邻接表        List&lt;List&lt;Integer&gt;&gt; adjs = new ArrayList&lt;&gt;();        int[] indegrees = new int[n];        for(int i = 0; i &lt; n; i ++){            adjs.add(new ArrayList&lt;&gt;());        }        for(int[] prerequisite : prerequisites){            adjs.get(prerequisite[1]).add(prerequisite[0]);            indegrees[prerequisite[0]] ++;        }        // 2.队列初始化：入度为0的节点入队        Deque&lt;Integer&gt; queue = new LinkedList&lt;&gt;();         int visitedNum = 0;        for(int i = 0; i &lt; n; i ++){            if(indegrees[i] == 0){                queue.add(i);            }        }        while(!queue.isEmpty()){            // 3.队头节点出队            int cur = queue.poll();            visitedNum ++;            // 4.更新入度，将节点的邻接节点入度-1            for(int next : adjs.get(cur)){                indegrees[next] --;                if(indegrees[next] == 0){                    // 5.入度为0，入队                    queue.add(next);                }            }        }        if(visitedNum != n) return false;        return true;    }}</code></pre><h4 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h4><p>时间：O(n+e)<br>空间：O(n+e) (邻接表)</p><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p><a href="https://leetcode.cn/problems/course-schedule-ii/">lc210课程表Ⅱ</a></p><h3 id="SPFA-判断负环"><a href="#SPFA-判断负环" class="headerlink" title="SPFA-判断负环"></a>SPFA-判断负环</h3><p>负环就是图中的环边权和为负。</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>节点入队次数超过n说明存在负环</p><blockquote><p>注：若节点无负环，某个节点最多可入队n-1次，因此只要入队&gt;=n就肯定是负环啦~判断负环写&gt;n或&gt;=n都可以</p></blockquote><h4 id="算法模板-2"><a href="#算法模板-2" class="headerlink" title="算法模板"></a>算法模板</h4><pre><code>class Solution {    class Edge{        int v; //终点        int weight; //边权        Edge(){}        Edge(int v, int weight){            this.v = v;            this.weight = weight;        }    }    int INF = 0x3f3f3f; // 之所以不使用Integer.MAX_VALUE，是因为松弛操作时可能会溢出变成负数    int[] dist; //dist[x] = y 表示从源点k到x的最短距离为y    List&lt;List&lt;Edge&gt;&gt; adjs; //邻接表    int n, k;    public int networkDelayTime(int[][] times, int n, int k) {        this.n = n;        this.k = k;        int e = times.length;        adjs = new ArrayList&lt;&gt;();        // 1.建立邻接表        for(int i = 0; i &lt;= n; i ++){            adjs.add(new ArrayList&lt;&gt;());        }        for(int[] time : times){            adjs.get(time[0]).add(new Edge(time[1], time[2]));        }        // 2.dist初始化        dist = new int[n+1];        Arrays.fill(dist, INF);        dist[k] = 0; // 起点自己到自己的距离为0        // 3.判断负环，存在负环返回true        return spfa();    }    // 存在负环则返回true    boolean spfa(){        boolean[] isInQueue = new boolean[n+1]; // 记录节点是否已在队列中        int[] inQueueNum = new int[n+1]; // 记录节点入队次数        Deque&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); // 建立队列        queue.add(k); // 源点入队        isInQueue[k] = true;        inQueueNum[k] ++;        while(!queue.isEmpty()){            int u = queue.poll();            //用u点当前的最短路径估计值对u点所指向的结点v进行松弛操作            for(Edge edge : adjs.get(u)){                int newPath = dist[u] + edge.weight;                if(dist[edge.v] &gt; newPath){                    dist[edge.v] = newPath;                    // 如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾                    if(isInQueue[edge.v]) continue;                    queue.add(edge.v);                    isInQueue[edge.v] = true;                    inQueueNum[edge.v] ++;                    if(inQueueNum[edge.v] &gt; n) return true; //入队超过n次，存在负环                }            }            isInQueue[u] = false; // u不在队列中了，进行出队操作        }        return false;    }}</code></pre><h4 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h4><p>时间：O(ke)， 其中k为所有顶点进队的平均次数，可以证明k一般小于等于2，最差还是O(n*e)<br>空间：O(m) </p><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>生成树就是一个极小的连通子图，包括n个节点和n-1条边，最小生成树就是带权图中边的权值最小的生成树。</p><h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><pre><code>- 基于贪心- 把所有的边按照权值先从小到大排列，接着按照顺序选取每条边，如果这条边的两个端点不属于同一集合，那么就将它们合并，直到所有的点都属于同一个集合为止。按照这个思路，Kruskal算法应基于并查集实现。</code></pre><h4 id="并查集算法模板"><a href="#并查集算法模板" class="headerlink" title="并查集算法模板"></a>并查集算法模板</h4><h2 id="单源最短路径（边权为正）"><a href="#单源最短路径（边权为正）" class="headerlink" title="单源最短路径（边权为正）"></a>单源最短路径（边权为正）</h2><p>单源最短路径指从一个节点出发到其他所有节点的最短路径。</p><pre><code>class Edge{    int node; //该边指向的节点    int weight; //边权    Edge(){}    Edge(int node, int weight){        this.node = node;        this.weight = weight;    }}List&lt;List&lt;Edge&gt;&gt; adjs; //邻接表int[] dist; //dist[x] = y 表示从源点k到x的最短距离为yint n, k;public int networkDelayTime(int[][] times, int n, int k) {    this.n = n;    this.k = k;    // 1.建立邻接表    List&lt;List&lt;Edge&gt;&gt; adjs = new ArrayList&lt;&gt;();    for(int i = 0; i &lt; n; i ++){        adjs.add(new ArrayList&lt;&gt;());    }    for(int[] time : times){        int u = time[0], v = time[1], w = time[2];        adjs.get(u).add(new Edge(v, w));    }    // 2.dist初始化    dist = new int[n];    Arrays.fill(dist, Integer.MAX_VALUE);    // 3.求最短路    bf();    // 4.遍历答案    int sum = 0;    for(int i = 0; i &lt; n; i ++){        if(dist[i] == Integer.MAX_VALUE){            return -1;        }else{            sum += dist[i];        }    }}</code></pre><h2 id="单源最短路径（边权有负）"><a href="#单源最短路径（边权有负）" class="headerlink" title="单源最短路径（边权有负）"></a>单源最短路径（边权有负）</h2><h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h3><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ul><li>对<strong>所有的边</strong>进行n-1轮松弛操作，因为在一个含有n个顶点的图中，任意两点之间的最短路径最多包含n-1边。<br>换句话说，第1轮在对所有的边进行松弛后，得到的是源点最多经过一条边到达其他顶点的最短距离；第2轮在对所有的边进行松弛后，得到的是源点最多经过两条边到达其他顶点的最短距离；第3轮在对所有的边进行松弛后，得到的是源点最多经过三条边到达其他顶点的最短距离……</li><li>优点：更具通用性，负权/负环也可以使用，能够求有边数限制的最短距离</li><li>缺点：复杂度高</li></ul><blockquote><p>参考<br><a href="https://zhuanlan.zhihu.com/p/72185593">https://zhuanlan.zhihu.com/p/72185593</a></p></blockquote><h4 id="算法模板（遍历每条边，适合边稀疏）"><a href="#算法模板（遍历每条边，适合边稀疏）" class="headerlink" title="算法模板（遍历每条边，适合边稀疏）"></a>算法模板（遍历每条边，适合边稀疏）</h4><pre><code>class Solution {    class Edge{        int u; //始点        int v; //终点        int weight; //边权        Edge(){}    }    int INF = 0x3f3f3f; // 之所以不使用Integer.MAX_VALUE，是因为松弛操作时可能会溢出变成负数    int[] dist; //dist[x] = y 表示从源点k到x的最短距离为y    Edge[] edges; //边集    int n, k;    public int minimumPath(int[][] times, int n, int k) {        this.n = n;        this.k = k;        int e = times.length;        edges = new Edge[e];        // 1.建立边集        for(int i = 0; i &lt; e; i ++){            edges[i] = new Edge();            edges[i].u = times[i][0];            edges[i].v = times[i][1];            edges[i].weight = times[i][2];        }        // 2.dist初始化        dist = new int[n+1];        Arrays.fill(dist, INF);        dist[k] = 0; // 起点自己到自己的距离为0        // 3.求最短路Bellman-Ford        bf(); //Bellman-Ford        // 4.遍历答案        int sum = 0;        for(int i = 1; i &lt;= n; i ++){            if(dist[i] == INF){                return -1;            }else{                sum = Math.max(sum, dist[i]);            }        }        return sum;    }    void bf(){        // 迭代n-1次，每次都使用上一次迭代结果执行松弛操作        // 第i轮循环的dist[v]表示从源点出发最多经过i条边到达节点v的最小距离        for(int i = 1; i &lt;= n-1; i ++){            int[] prev = dist.clone(); //上一次的结果            // 遍历所有边，对节点进行松弛操作            for(Edge edge : edges){                int u = edge.u, v = edge.v, w = edge.weight;                dist[v] = Math.min(dist[v], prev[u] + w);            }        }    }}</code></pre><blockquote><p>INF = 0x3f3f3f<br>    1. 防止溢出变为负数；<br>    2. 整数的两倍不超过 0x7f7f7f7f，即int能表示的最大正整数。满足无穷大+无穷大=无穷大，不会溢出。<br>    参考：<a href="https://blog.csdn.net/jiange_zh/article/details/50198097">https://blog.csdn.net/jiange_zh/article/details/50198097</a></p></blockquote><h4 id="复杂度-3"><a href="#复杂度-3" class="headerlink" title="复杂度"></a>复杂度</h4><p>时间：O(n*e)<br>空间：O(m) </p><h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h4><p><a href="https://leetcode.cn/problems/network-delay-time/">lc743网络延迟时间</a>  </p><h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><ul><li>在Bellman-ford算法的基础上加上一个队列优化，减少了冗余的松弛操作。SPFA相当于是Bellman-Ford算法的一个优化版本，在Bellman-Ford算法中，很多松弛操作其实都是没有必要的，例如对于一条从 x 到 y 的边，如果连 x 都还没被松弛，那 y 肯定也还不能被 x 松弛。<br>为了避免“用一个还没有被松弛的点去松弛另外的点”的情况，引入队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。</li><li>可以用来判断负环，方法见上文<blockquote><p>参考：<br>  <a href="https://blog.csdn.net/weixin_32203421/article/details/114068323">https://blog.csdn.net/weixin_32203421/article/details/114068323</a><br>  <a href="https://blog.csdn.net/forever_dreams/article/details/81161527">https://blog.csdn.net/forever_dreams/article/details/81161527</a></p></blockquote></li></ul><h4 id="算法模板-3"><a href="#算法模板-3" class="headerlink" title="算法模板"></a>算法模板</h4><pre><code>class Solution {    class Edge{        int v; //终点        int weight; //边权        Edge(){}        Edge(int v, int weight){            this.v = v;            this.weight = weight;        }    }    int INF = 0x3f3f3f; // 之所以不使用Integer.MAX_VALUE，是因为松弛操作时可能会溢出变成负数    int[] dist; //dist[x] = y 表示从源点k到x的最短距离为y    List&lt;List&lt;Edge&gt;&gt; adjs; //邻接表    int n, k;    public int networkDelayTime(int[][] times, int n, int k) {        this.n = n;        this.k = k;        int e = times.length;        adjs = new ArrayList&lt;&gt;();        // 1.建立邻接表        for(int i = 0; i &lt;= n; i ++){            adjs.add(new ArrayList&lt;&gt;());        }        for(int[] time : times){            adjs.get(time[0]).add(new Edge(time[1], time[2]));        }        // 2.dist初始化        dist = new int[n+1];        Arrays.fill(dist, INF);        dist[k] = 0; // 起点自己到自己的距离为0        // 3.求最短路        spfa();        // 4.遍历答案        int sum = 0;        for(int i = 1; i &lt;= n; i ++){            if(dist[i] == INF){                return -1;            }else{                sum = Math.max(sum, dist[i]);            }        }        return sum;    }    void spfa(){        boolean[] isInQueue = new boolean[n+1]; // 记录节点是否已在队列中        Deque&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); // 建立队列        queue.add(k); // 源点入队        isInQueue[k] = true;        while(!queue.isEmpty()){            int u = queue.poll();            //用u点当前的最短路径估计值对u点所指向的结点v进行松弛操作            for(Edge edge : adjs.get(u)){                int newPath = dist[u] + edge.weight;                if(dist[edge.v] &gt; newPath){                    dist[edge.v] = newPath;                    // 如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾                    if(isInQueue[edge.v]) continue;                    queue.add(edge.v);                    isInQueue[edge.v] = true;                }            }            isInQueue[u] = false; // u不在队列中了，进行出队操作        }    }}</code></pre><h4 id="复杂度-4"><a href="#复杂度-4" class="headerlink" title="复杂度"></a>复杂度</h4><p>时间：O(ke)， 其中k为所有顶点进队的平均次数，可以证明k一般小于等于2，最差还是O(n*e)<br>空间：O(m) </p><h4 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h4><p><a href="https://leetcode.cn/problems/network-delay-time/">lc743网络延迟时间</a>  </p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fabric的Dev模式初探</title>
      <link href="/2022/11/03/1103-fabric-devmode/"/>
      <url>/2022/11/03/1103-fabric-devmode/</url>
      
        <content type="html"><![CDATA[<h1 id="Fabric的Dev模式初探"><a href="#Fabric的Dev模式初探" class="headerlink" title="Fabric的Dev模式初探"></a>Fabric的Dev模式初探</h1><p>Fabric的Dev模式用于在开发智能合约（链码）时绕过链码声明周期指令，对开发的链码进行快速测试。<br>官方文档参考：<a href="https://hyperledger-fabric.readthedocs.io/en/latest/peer-chaincode-devmode.html#start-the-chaincode">https://hyperledger-fabric.readthedocs.io/en/latest/peer-chaincode-devmode.html#start-the-chaincode</a></p><h2 id="环境搭建-启动orderer"><a href="#环境搭建-启动orderer" class="headerlink" title="环境搭建+启动orderer"></a>环境搭建+启动orderer</h2><ol><li><p>克隆Fabric并切换到所需版本分支，此处以2.4版本举例</p><pre><code>git clone https://github.com/hyperledger/fabricgit checkout release-2.4cd fabric</code></pre></li><li><p>编译orderer、peer和configtxgen</p><pre><code>make orderer peer configtxgen</code></pre></li><li><p>设置orderer、peer和configtxgen的环境变量</p><pre><code>export PATH=$(pwd)/build/bin:$PATHexport FABRIC_CFG_PATH=$(pwd)/sampleconfig</code></pre></li><li><p>创建<code>/var/hyperledger</code>作为存放区块的默认文件夹（区块默认位置可以在<code>orderer.yaml</code>和<code>core.yaml</code>中修改）</p><pre><code>sudo mkdir /var/hyperledgersudo chown root /var/hyperledger # sudo chown 用户名 /var/hyperledger</code></pre></li><li><p>为ordering service生成创世区块</p><pre><code>configtxgen -profile SampleDevModeSolo -channelID syschannel -outputBlock genesisblock -configPath $FABRIC_CFG_PATH -outputBlock "$(pwd)/sampleconfig/genesisblock"</code></pre><blockquote><p>创世区块（genesis block）：区块链中编号为0的区块</p></blockquote></li><li><p>启动orderer</p><pre><code>ORDERER_GENERAL_GENESISPROFILE=SampleDevModeSolo orderer</code></pre></li></ol><h2 id="启动peer"><a href="#启动peer" class="headerlink" title="启动peer"></a>启动peer</h2><ol><li>另起一个终端，打开克隆的fabric文件夹并设置环境变量<pre><code>export PATH=$(pwd)/build/bin:$PATHexport FABRIC_CFG_PATH=$(pwd)/sampleconfig</code></pre></li><li>为了使orderer和peer在同一环境中运行，需要更改监听地址<pre><code>export CORE_OPERATIONS_LISTENADDRESS=127.0.0.1:9444</code></pre></li><li>启动peer<pre><code>FABRIC_LOGGING_SPEC=chaincode=debug CORE_PEER_CHAINCODELISTENADDRESS=0.0.0.0:7052 peer node start --peer-chaincodedev=true</code></pre></li></ol><h2 id="创建channel并加入peer"><a href="#创建channel并加入peer" class="headerlink" title="创建channel并加入peer"></a>创建channel并加入peer</h2><ol><li><p>另起一个终端，打开克隆的fabric文件夹并设置环境变量</p><pre><code>export PATH=$(pwd)/build/bin:$PATHexport FABRIC_CFG_PATH=$(pwd)/sampleconfig</code></pre></li><li><p>创建channel<br> 下面示例中的channel名称为ch1，使用<code>configtx.yaml</code>中的<code>SampleSingleMSPChannel</code>profile进行channel配置，成功后会在fabric中生成<code>ch1.tx</code></p><pre><code>configtxgen -channelID ch1 -outputCreateChannelTx ch1.tx -profile SampleSingleMSPChannel -configPath $FABRIC_CFG_PATHpeer channel create -o 127.0.0.1:7050 -c ch1 -f ch1.tx</code></pre></li><li><p>加入peer，成功后会在fabric中生成<code>ch1.block</code></p><pre><code>peer channel join -b ch1.block</code></pre></li></ol><h2 id="启动链码"><a href="#启动链码" class="headerlink" title="启动链码"></a>启动链码</h2><ol><li><p>编译链码（go举例）<br> 这里我的文件在integration/chaincode/ec下</p><pre><code># 如果go文件中有扩展包，如fabric-contract-api-go，首先执行以下两条命令，没有扩展包可以跳过这两条go mod tidygo mod vendor# 编译go文件，这里`ecChaincode`为编译后生成的文件名go build -o ecChaincode ./integration/chaincode/ec/</code></pre></li><li><p>启动链码<br> 其中<code>CORE_CHAINCODE_ID_NAME</code>的构成为<code>链码名称:链码版本号</code></p><pre><code>CORE_CHAINCODE_LOGLEVEL=debug CORE_PEER_TLS_ENABLED=false CORE_CHAINCODE_ID_NAME=ec:1.0 ./ecChaincode -peer.address 127.0.0.1:7052</code></pre></li></ol><h2 id="批准并提交链码定义"><a href="#批准并提交链码定义" class="headerlink" title="批准并提交链码定义"></a>批准并提交链码定义</h2><ol><li><p>另起一个终端，打开克隆的fabric文件夹并设置环境变量</p><pre><code>export PATH=$(pwd)/build/bin:$PATHexport FABRIC_CFG_PATH=$(pwd)/sampleconfig</code></pre></li><li><p>批准并提交<br> <code>--channelID</code>指定channel名称，<code>--name</code>指定链码名称，<code>--version</code>指定链码版本，<code>--package-id</code>指定链码的包名称（需和上一步定义的一样）</p><pre><code>peer lifecycle chaincode approveformyorg -o 127.0.0.1:7050 --channelID ch1 --name ec --version 1.0 --sequence 1 --init-required --signature-policy "OR ('SampleOrg.member')" --package-id ec:1.0peer lifecycle chaincode checkcommitreadiness -o 127.0.0.1:7050 --channelID ch1 --name ec --version 1.0 --sequence 1 --init-required --signature-policy "OR ('SampleOrg.member')"peer lifecycle chaincode commit -o 127.0.0.1:7050 --channelID ch1 --name ec --version 1.0 --sequence 1 --init-required --signature-policy "OR ('SampleOrg.member')" --peerAddresses 127.0.0.1:7051</code></pre></li></ol><h2 id="调用链码"><a href="#调用链码" class="headerlink" title="调用链码"></a>调用链码</h2><p>格式：<code>CORE_PEER_ADDRESS=127.0.0.1:7051 peer chaincode invoke -o 127.0.0.1:7050 -C ch1 -n mycc -c '{"Args":["方法名称","参数1","参数2","参数3"]}'</code><br>如：</p><pre><code>CORE_PEER_ADDRESS=127.0.0.1:7051 peer chaincode invoke -o 127.0.0.1:7050 -C ch1 -n ec -c '{"Args":["InitLedger"]}' --isInitCORE_PEER_ADDRESS=127.0.0.1:7051 peer chaincode invoke -o 127.0.0.1:7050 -C ch1 -n ec -c '{"Args":["GetAllAssets"]}'CORE_PEER_ADDRESS=127.0.0.1:7051 peer chaincode invoke -o 127.0.0.1:7050 -C ch1 -n ec -c '{"Args":["ReadAsset","asset1-0"]}'CORE_PEER_ADDRESS=127.0.0.1:7051 peer chaincode invoke -o 127.0.0.1:7050 -C ch1 -n ec -c '{"Args":["CreateLedger","5","3","1"]}'</code></pre>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【知识记录】JVM知识记录（下）</title>
      <link href="/2022/10/04/1004-jvm/"/>
      <url>/2022/10/04/1004-jvm/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="如何判断对象可以回收"><a href="#如何判断对象可以回收" class="headerlink" title="如何判断对象可以回收"></a>如何判断对象可以回收</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><ul><li>变量被其他对象引用了几次就计几次数，一个对象不再引用它了则计数-1，计数为0时就表示没有对象引用它了，可以作为垃圾被回收</li><li>弊端：循环引用<br>  A引用B，B引用A，A和B计数都为1，但也都不能变成0，无法被回收，导致内存泄漏。</li></ul><h3 id="可达性分析法（JVM采用）"><a href="#可达性分析法（JVM采用）" class="headerlink" title="可达性分析法（JVM采用）"></a>可达性分析法（JVM采用）</h3><ul><li>通俗解释：<ol><li>确定根对象（即肯定不能当成垃圾被回收的对象）</li><li>扫描所有对象，如果被根对象直接或间接引用就不能被垃圾回收，反之可以作为垃圾，将来会被回收</li></ol></li><li>具体做法<br>  扫描堆中的对象，看是否能够沿着以GC Root对象为起点的引用链接找到该对象，找不到就表示可以被回收</li><li>可以作为GC Root的对象<ul><li>系统类：启动类加载器加载的类</li><li>Native Stack（本地方法）：本地方法执行时用到的java对象</li><li>busy monitor（锁）：被加锁的对象</li><li>活动线程：线程中正在使用的对象，即java栈帧内使用的对象（比如局部变量引用的<strong>对象</strong>，<em>注意局部变量本身不算，它在栈里，不再堆里</em>）<blockquote><p>Eclipse的Memory Analyzer(MAT)：堆分析工具<br>  先通过jmap抓取内存快照，再使用MAT，即：<br>  <code>jmap -dump:format=b,live,file=快照文件名.bin 线程id</code><br>  然后在MAT打开bin文件<br>  <em>注意：jmap的live是查看没有被回收的对象，所以带有该参数的jmap时会进行一次垃圾回收</em></p></blockquote></li></ul></li></ul><h3 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h3><ul><li>强引用<br>  一般我们创建的都是强引用<br>  只要沿着GC Root的引用链能找到它就不会被垃圾回收</li><li>软引用<ul><li>只要没有被强引用直接引用，就有可能被垃圾回收</li><li><strong>当垃圾回收且内存不够</strong>，且没有其他强引用引用，就会把软引用引用的对象回收掉</li><li><strong>可以配合</strong>引用队列：软引用引用的对象被回收后，软引用自身会进入到这个队列（为了释放软引用自身占用的内存，之所以使用队列是因为软引用自身可能被强引用引用着）</li><li>应用：存储不太重要的占内存的资源，比如图片资源啥的，如：<br>  <code>List&lt;byte[]&gt; -&gt; List&lt;SoftReference&lt;byte[]&gt;&gt;</code>，防止堆内存溢出。<pre><code>List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();ReferenceQueue&lt;byte[]&gt; queue = new ReferenceQueue&lt;&gt;();while(...){    SoftReference&lt;byte[]&gt; ref = new SoftReference&lt;&gt;(new byte[n], queue); //关联软引用对象和引用队列：当软引用对象引用的byte数组被回收时，软引用自身就会被加入到quque中去    list.add(ref);}//从队列中获取无用的软引用并移除Reference&lt;? extends byte[]&gt; poll = queue.poll();while(poll != null){    list.remove(poll); //移除没用的软引用    poll = queue.poll();}</code></pre></li></ul></li><li>弱引用<ul><li>只要没有被强引用直接引用，就有可能被垃圾回收</li><li><strong>只要发生了垃圾回收</strong>，且没有其他强引用引用，就会把弱引用引用的对象回收掉</li><li><strong>可以配合</strong>引用队列：弱引用引用的对象被回收后，弱引用自身会进入到这个队列（为了释放弱引用自身占用的内存，原因同上）</li><li>应用：ThreadLocal中的ThreadLocalMap的key使用的是弱引用<blockquote><p>为什么ThreadLocal中的ThreadLocalMap的key使用的是弱引用？<br>  参考：<a href="https://zhuanlan.zhihu.com/p/304240519">https://zhuanlan.zhihu.com/p/304240519</a><br>  假设我们在A类的内部使用到了ThreadLocal，如果是强引用，当不调用A类的对象时，A对象被回收，但是其内部使用的ThreadLocal不会被回收，因为通过Thread -&gt; ThreadLocal.ThreadLocalMap -&gt; Entry[] -&gt; Enrty -&gt; key（threadLocal对象）和value这么一串调用，key还是强引用，但是已经访问不到了。<br>  综上，<strong>Entry的key被设计为弱引用就是为了让程序自动的对访问不到的数据进行回收提醒</strong>，所以，在访问不到的数据被回收之前，内存泄漏确实是存在的。</p></blockquote></li></ul></li><li>虚引用<ul><li>（感觉就是为了在垃圾回收对象后做一些额外处理）</li><li><strong>必须配合</strong>引用队列</li><li>典型用法：处理bytebuffer这种对象，当没有强引用连接ByteBuffer时，ByteBuffer被回收，但它分配的直接内存还在，此时将虚引用Cleaner加入引用队列，当引用队列中的ReferenceHandler发现该虚引用后，调用Cleaner中的clean方法，通过直接内存地址找到被分配的直接内存并释放。</li></ul></li><li>终结器引用<ul><li>用于管理重写过finalize()的类的对象，finalize()用于执行一些对象回收前的清理工作，在jdk9时已过时</li><li><strong>必须配合</strong>引用队列 </li><li>若一个类重写了Object的finalize()方法，当没有强引用指向对象，对象准备被回收时，会先把终结器引用放入引用队列，再由一个优先级很低的线程（finalize hanlder）查看引用队列是否有终结器引用，若有，则根据终结器引用找到要被回收的对象，并且调用finalize()方法，调用完成后，<strong>下一次垃圾回收时</strong>就可以把该对象回收掉。=&gt;第一次回收入队，执行finalize()，执行后的下一次回收才真正回收，效率低（回收两次，finalize hanlder执行频率低），不建议使用finalize()</li></ul></li></ul><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>JVM会结合不同情况采用以下三种垃圾回收算法</p><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><ul><li>步骤<ol><li>先标记<br>  判断哪些对象可以被回收</li><li>后清除<br>  释放垃圾对象：<strong>只是将垃圾对象的起始地址和结束地址放在空闲列表中</strong>，不会对垃圾对象占用的内存进行清0处理</li></ol></li><li>优点：速度快</li><li>缺点：容易产生内存碎片<br><img src="/image/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png" title="垃圾回收算法-标记清除" loading="lazy"></li></ul><h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><ul><li>步骤<ol><li>先标记<br>  判断哪些对象可以被回收</li><li>后整理<br>  整理原因：避免标记清除产生的内存碎片问题<br>  会把已用的内存空间进行<strong>紧凑</strong>，增大连续的内存空间</li></ol></li><li>优点：内存碎片少</li><li>缺点：内存空间会移动，速度慢<br><img src="/image/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95-%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png" title="垃圾回收算法-标记整理" loading="lazy"></li></ul><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><ul><li>结构<br>划分大小相同的两块内存区：from和to，to中始终空闲</li><li>步骤<ol><li>标记<br>  判断哪些对象可以被回收</li><li>复制<br>  把from中尚存的非垃圾对象复制到to区中，复制过程中完成整理（其实就是在to区中连续存放，反正to区是空的），复制完成后，清空from区，并且交换from和to的位置（from区变to区，to区变from区）</li></ol></li><li>优点：不会产生碎片</li><li>缺点：占用双倍内存空间<br><img src="/image/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95-%E5%A4%8D%E5%88%B6.png" title="垃圾回收算法-复制" loading="lazy"></li></ul><h2 id="分代垃圾回收机制"><a href="#分代垃圾回收机制" class="headerlink" title="分代垃圾回收机制"></a>分代垃圾回收机制</h2><h3 id="堆内存结构划分"><a href="#堆内存结构划分" class="headerlink" title="堆内存结构划分"></a>堆内存结构划分</h3><ul><li>新生代<ul><li>伊甸园</li><li>幸存区<ul><li>幸存区From</li><li>幸存区To</li></ul></li></ul></li><li>老年代</li></ul><h3 id="划分原因"><a href="#划分原因" class="headerlink" title="划分原因"></a>划分原因</h3><p><strong>对象生命周期不同</strong>，需要长时间引用的对象放在老年代中，用完可以丢弃的对象放在新生代中，<strong>根据生命周期的特点可以采用不同的垃圾回收算法进行垃圾回收</strong></p><h3 id="回收机制"><a href="#回收机制" class="headerlink" title="回收机制"></a>回收机制</h3><ol><li>新创建的对象首先被分配在新生代的伊甸园中</li><li>当放入新对象时，发现伊甸园占满，触发Minor GC<br> Minor GC采用复制算法：<ul><li><p>第一次触发Minor GC，<strong>扫描伊甸区</strong>的对象，幸存的对象复制到To中，并且寿命+1，垃圾对象被回收，最后交换幸存区From和To的位置。</p></li><li><p>第二次触发Minor GC，<strong>扫描伊甸区和幸存From区</strong>的对象，幸存的对象复制到To中，并且寿命+1，垃圾对象被回收，最后交换幸存区From和To的位置。</p></li><li><p>此外，Minor GC会在工作中引发一次<strong>stop the world</strong>（stw，时间较短），会暂停其他用户线程，直到此次垃圾回收进行完了，用户线程才恢复运行。</p></li><li><p>晋升机制：</p><ul><li>情况1（长期存活的对象）：当对象的寿命超过一个阈值（最大寿命是15，4位（1111b）），就把它放到老年代去（飞升了~~~）</li><li>情况2（担保机制）：新创建对象时，如果内存实在很紧张，新生代没地方了，会把这个新对象提前晋升到老年代</li><li>情况3（大对象直接晋升老年代）：新生代地方肯定不够，老年代空间足够，直接晋升老年代，不会GC。<br>  怎么样算大对象可以通过<code>-XX:PretenureSizeThreshold=对象大小(单位：byte)</code>指定，该参数只对Serial和ParNew两款收集器有效</li><li>情况4（动态对象年龄判定）：当幸存者空间中相同年龄所有对象占用的内存总和大于幸存者空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，而不需要达到默认的分代年龄。</li></ul><p>  参考<a href="https://blog.csdn.net/qq_27184497/article/details/117828331">https://blog.csdn.net/qq_27184497/article/details/117828331</a></p></li></ul></li><li>当放入新对象时，发现新生代和老年代的空间均不足，且Minor GC后新生代内存还是不够，触发Full GC<ul><li>Full GC采用标记清除/标记整理</li><li>Full GC也会引起stw，不过相对于Minor GC的stw而言时间更长(因为存活的对象比较多，如果采用标记整理的话时间会更长)</li></ul></li><li>如果还不够，就OOM啦</li></ol><h3 id="相关虚拟机参数"><a href="#相关虚拟机参数" class="headerlink" title="相关虚拟机参数"></a>相关虚拟机参数</h3><ul><li><p>-Xms：堆初始大小</p></li><li><p>-Xmx：堆最大大小</p><blockquote><p>ps：Xms和Xmx默认是相等的，若不等，JVM就会根据堆内存的使用情况，动态的向操作系统申请内存，扩大或者是缩小，以-Xmx和-Xms的值为上下界，这里的每一次调整都会产生一定的系统开销。<br>  参考：<a href="https://blog.csdn.net/weixin_38106322/article/details/108197030">https://blog.csdn.net/weixin_38106322/article/details/108197030</a></p></blockquote></li><li><p>-Xmn：新生代大小（初始和最大同时指定）</p><ul><li>-XX:NewSize=size 初始</li><li>-XX:MaxNewSize=size 最大</li></ul></li><li><p>-XX:InitialSurvivorRatio=ratio和-XX:+UseAdaptiveSizePolicy：幸存区比例（动态调整）</p></li><li><p>-XX:SurvivorRatio=ratio：幸存区比例，默认值为8（伊甸园占新生代的80%）</p></li><li><p>-XX:MaxTenuringThreshold=threshold：晋升阈值（默认和垃圾回收器有关）</p></li><li><p>-XX:+PrintTenuringDistribution：晋升详情</p></li><li><p>-XX:+PrintGCDetails -verbose:gc：GC详情</p></li><li><p>-XX:+ScavengeBeforeFullGC：FullGC前MinorGC（默认打开）</p></li></ul><h3 id="实际GC分析"><a href="#实际GC分析" class="headerlink" title="实际GC分析"></a>实际GC分析</h3><ul><li>若给新生代划分10M，伊甸园占8M，新生区from、to各占1M，此时打印日志会显示新生区共占9M（因为to区那1M不能用）</li><li>线程内的OOM不会影响其他线程运行</li></ul><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h3><ul><li>单线程垃圾回收器</li><li>适用场景：堆内存较小，适合个人电脑CPU个数少的</li><li>开启参数：-XX:+UseSerialGC </li><li>两个部分：Serial和SerialOld两个垃圾回收器分别运行<ul><li>Serial<br>  工作在新生代，采用复制算法</li><li>SerialOld<br>  工作在老年代，采用标记+整理算法</li></ul></li><li>工作模式<br><img src="/image/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-%E4%B8%B2%E8%A1%8C.png" title="垃圾回收器-串行" loading="lazy"></li></ul><h3 id="吞吐量优先（1-8默认）"><a href="#吞吐量优先（1-8默认）" class="headerlink" title="吞吐量优先（1.8默认）"></a>吞吐量优先（1.8默认）</h3><ul><li><p>多线程垃圾回收器</p></li><li><p>适用场景：堆内存较大，需要多核CPU支持，适合工作在服务器上</p></li><li><p>目标：让单位时间内，stw的时间最短（单次stw时间时间可能比较长，如1小时内只发生两次stw，一次0.2，一小时中stw的时间为0.4）</p></li><li><p>开启参数：<code>-XX:+UseParallelGC和-XX:+UseParallelOldGC</code> （两个参数在1.8默认开启，开启一个就会把两个都打开）</p></li><li><p>工作模式</p></li><li><p>垃圾回收线程个数和CPU核数相关，<strong>垃圾回收时CPU占用率会直接飙到100%</strong><br>  垃圾回收线程数可通过<code>-XX:ParallelGCThreads=n</code>来控制（默认就是CPU核心数）<br><img src="/image/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88.png" title="垃圾回收器-吞吐量优先" loading="lazy"></p></li><li><p>可以根据目标设置垃圾回收器的回收方式<br>  与之相关参数：</p><ul><li><code>-XX:+UseAdaptiveSizePolicy</code> 动态调整新生代大小、伊甸园和幸存者区域比例、堆大小、晋升阈值<ul><li>目标1：<code>-XX:GCTimeRatio=ratio</code> 垃圾回收时间和总时间的占比 <code>1/(1+ratio)</code> <ul><li>默认ratio=99，即总时间中只有1%的时间会进行垃圾回收，如果超过这个时间，jvm就会调整策略（比如增加堆的大小）</li><li>一般设置成ratio=19，即5%的时间进行垃圾回收</li></ul></li><li>目标2：<code>-XX:MaxGCPauseMillis=ms</code> 执行单次垃圾回收的时间<ul><li>默认值是200ms  </li><li>若执行垃圾回收超过这个时间，jvm就会调整策略（比如减小堆的大小）</li><li>这个目标和目标1冲突，因为目标1调整后堆大了，那么垃圾回收的时间也会增长</li></ul></li></ul></li></ul></li></ul><h3 id="响应时间优先CMS"><a href="#响应时间优先CMS" class="headerlink" title="响应时间优先CMS"></a>响应时间优先CMS</h3><ul><li>多线程垃圾回收器</li><li>适用场景：堆内存较大，需要多核CPU支持，适合工作在服务器上</li><li>目标：让单次stw时间尽可能短（1小时内发生五次stw，一次0.1，一小时中stw时间为0.5，虽然总时间长，但单次短）</li><li>开启参数：<code>-XX:+UseConcMarkSweepGC</code>（CMS，并发标记清除GC，该并发表示GC和其他用户线程并发执行，工作在老年代，若并发失败，CMS垃圾回收器会退化成SerialOld）和<code>-XX:+UseParNewGC</code>（工作在新生代，基于复制算法）</li><li>工作模式<ul><li>并行垃圾回收线程数可通过<code>-XX:ParallelGCThreads=n</code>来控制（默认就是CPU核心数）</li><li>并发垃圾回收线程数可通过<code>-XX:ConcGCThreads=threads</code>（默认是(ParallelGCThreads+3)/4）</li><li>CMS垃圾回收器CPU占用率不高，但是会影响应用程序的吞吐量（因为有一个CPU核被GC占用了）</li><li>浮动垃圾：清理并发清理时，其他用户线程产生的新垃圾</li><li>不能在堆内存不足时做垃圾回收，因为CMS GC和用户线程并发执行，需要给用户线程预留内存空间支持用户线程执行，通过<code>-XX:CMSInitialtingOccupancyFraction=percent</code>调节垃圾回收时间（如设置成80就表示老年代占用了80%的空间时执行一次CMS）</li><li>可能有新生代的对象引用了老年代的对象，在重新标记阶段影响大（因为新生代垃圾多，有可能那个新生代对象就是垃圾），通过<code>-XX:+CMSScavengeBeforeRemark</code>在重新标记前对新生代对象进行一次垃圾回收</li><li>CMS采用标记清理算法，若老年代内存碎片过多，会导致并发失败，会退化为SerialOld，做一次串行的GC进行标记整理（垃圾回收时间会一下子飚上来。。。）<br><img src="/image/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88.png" title="垃圾回收器-响应时间优先" loading="lazy"></li></ul></li></ul><h3 id="G1垃圾回收器（JDK9默认）"><a href="#G1垃圾回收器（JDK9默认）" class="headerlink" title="G1垃圾回收器（JDK9默认）"></a>G1垃圾回收器（JDK9默认）</h3><ul><li>JDK9废弃了CMS GC</li><li>适用场景<ul><li>同时注重吞吐量和低延迟，默认暂停目标是200ms，可以通过<code>-XX:MaxGCPauseMillis=time</code>调整，time变大了那吞吐量更高</li><li>适合堆内存超大的服务器，会将堆划分为多个大小相等的Region</li><li><strong>整体上是标记+整理算法，两个区域之间是复制算法</strong></li></ul></li><li>开启参数<br>  JDK7和8需要使用，JDK9及之后默认开启<br>  <code>-XX:+UseG1GC</code></li></ul><h4 id="G1垃圾回收器的分区"><a href="#G1垃圾回收器的分区" class="headerlink" title="G1垃圾回收器的分区"></a>G1垃圾回收器的分区</h4><ul><li>G1垃圾回收器将堆划分为多个大小相等的Region，<strong>每个Region都可以独立的作为伊甸园、幸存区或老年代</strong>，可以通过<code>-XX:G1HeapRegionSize=size</code>调整。（比如可能有4个伊甸园，2个幸存区，8个老年代）</li><li>伊甸园E、幸存区S、老年代O、巨型对象H（后边细说）</li></ul><h4 id="G1垃圾回收阶段（循环过程）"><a href="#G1垃圾回收阶段（循环过程）" class="headerlink" title="G1垃圾回收阶段（循环过程）"></a>G1垃圾回收阶段（循环过程）</h4><ol><li>阶段1：新生代垃圾回收<br> 当老年代内存超过一定阈值，转到阶段2</li><li>阶段2：新生代垃圾回收+并发标记<br> 阶段2完成后转到阶段3</li><li>阶段3：混合回收<br> 对新生代和老年代都进行垃圾回收，内存释放掉后转向阶段1</li></ol><h4 id="新生代垃圾回收"><a href="#新生代垃圾回收" class="headerlink" title="新生代垃圾回收"></a>新生代垃圾回收</h4><p><strong>会STW</strong><br>划分区域中的伊甸园区被占满，触发新生代垃圾回收，依靠复制算法把幸存对象复制到幸存区，幸存区晋升老年代还是和以前一样。</p><h4 id="新生代垃圾回收-并发标记（CM-Concurrent-Marking"><a href="#新生代垃圾回收-并发标记（CM-Concurrent-Marking" class="headerlink" title="新生代垃圾回收+并发标记（CM,Concurrent Marking)"></a>新生代垃圾回收+并发标记（CM,Concurrent Marking)</h4><ul><li>在新生代垃圾回收时进行GC Root初始标记</li><li>老年代占用堆空间比例达到阈值时，进行并发标记（<strong>不会STW</strong>），由参数<code>-XX:InitiatingHeapOccupancyPercent=percent</code>决定（默认45，即占老年代占堆空间的45%时触发并发标记)</li></ul><h4 id="混合回收"><a href="#混合回收" class="headerlink" title="混合回收"></a>混合回收</h4><ul><li>对E、S、O进行全面垃圾回收<ul><li>E：就是之前的复制算法</li><li>S：有的S会把年龄不够的复制到别的S中，年龄到阈值的复制到老年代</li><li>O：根据规定的最大GC时间，会将最具回收价值的垃圾区域进行回收，并把该区域中存活的对象拷贝到别的O中，达到整理内存减少空间碎片的效果。（如果把所有的O都回收一遍还能再最大GC时间内就会全拷贝一遍）<br><img src="/image/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-G1%E6%B7%B7%E5%90%88%E9%98%B6%E6%AE%B5.png" title="混合回收" loading="lazy"></li></ul></li><li>两个阶段<ul><li>最终标记 <strong>会STW</strong><br>  就是那个remark，标记并发标记时漏掉的垃圾</li><li>拷贝存活 <strong>会STW</strong><br>  就是ESO的存活对象拷贝（注意不是所有老年代的垃圾都会被回收哦）</li></ul></li></ul><h3 id="Full-GC和Minor-GC总结辨析"><a href="#Full-GC和Minor-GC总结辨析" class="headerlink" title="Full GC和Minor GC总结辨析"></a>Full GC和Minor GC总结辨析</h3><ul><li>新生代内存不足发生的垃圾收集<ul><li>Serial GC、ParallelGC、CMS、G1<br>  均采用minor GC</li></ul></li><li>老年代内存不足发生的垃圾收集<ul><li>Serial GC、ParallelGC<br>  均采用full GC</li><li>CMS<br>  到达阈值：并发回收/Full GC<ul><li>老年代内存不足导致Full GC，具体原因有：<ul><li>promotion failed：晋升失败，Minor GC过程中同时有对象要放入老年代，而此时老年代空间不足</li><li>concurrent mode failure：并发模式失败<ul><li>产生新垃圾的速度&gt;并发垃圾回收速度（执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足）</li><li>还有一种可能是老年代碎片太多</li></ul></li></ul></li></ul></li><li>G1<br>  到达阈值：并发回收/Full GC<ul><li>产生新垃圾的速度&lt;并发垃圾回收速度：并发垃圾回收</li><li>产生新垃圾的速度&gt;并发垃圾回收速度：并发垃圾回收失败，退化为Serial GC，执行Full GC</li></ul></li></ul></li></ul><h3 id="新生代垃圾回收跨代引用（老年代引用新生代）"><a href="#新生代垃圾回收跨代引用（老年代引用新生代）" class="headerlink" title="新生代垃圾回收跨代引用（老年代引用新生代）"></a>新生代垃圾回收跨代引用（老年代引用新生代）</h3><ul><li>原因：Minor GC要进行GC Root扫描，可能有些GC Root在老年代中，但是老年代对象太多了，全扫描效率低</li><li>解决：卡表+Remembered Set 提高GC Root扫描效率，加速新生代垃圾回收<ul><li>O中的卡表（每个512KB）：如果一个卡中的对象引用了新生代对象，就标记为脏卡。因此进行GC Root扫描时在老年代只需要扫描老年代的脏卡，提高效率。</li><li>E中的Remembered Set：记录外部有哪些脏卡。因此E可以知道对应了哪些脏卡，只去对应的脏卡进行扫描即可。</li></ul></li><li>标记脏卡是在每次对象引用变更时进行（post-write barrier)，这是一个异步操作，会把更新指令放到dirty card queue中，将来由一个线程执行（异步队列~）<br><img src="/image/G1-%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8.png" title="跨代引用" loading="lazy"></li></ul><h3 id="重标记Remark"><a href="#重标记Remark" class="headerlink" title="重标记Remark"></a>重标记Remark</h3><ul><li>并发标记过程（三色标记法）：<br>把对象处理一遍，最后还被标为白色的对象就是垃圾<br><img src="/image/G1-%E9%87%8D%E6%96%B0%E6%A0%87%E8%AE%B0.png" title="重新标记" loading="lazy"></li><li>问题：<br>GC与用户线程并发，可能并发标记进行时，白色的垃圾又被黑色的对象引用了</li><li>解决：重新标记</li><li>写屏障post-write barrier：如果一个垃圾的引用发生改变，触发写屏障，此时会将垃圾对象加入到队列satb_mark_queue中，颜色标记为灰色（正在处理）。等到并发标记结束后，发生stw，然后重新标记线程会对队列重新进行一次检查，如果发现有强引用还在引用队列里的对象，该对象会被重新标为黑色。</li></ul><h3 id="G1优化"><a href="#G1优化" class="headerlink" title="G1优化"></a>G1优化</h3><h4 id="JDK-8u20-字符串去重"><a href="#JDK-8u20-字符串去重" class="headerlink" title="JDK 8u20 字符串去重"></a>JDK 8u20 字符串去重</h4><ul><li>参数（默认打开）：-XX:+UseStringDeduplication</li><li>步骤<ol><li>将所有新分配的字符串放入一个队列</li><li>当新生代回收时，G1并发检查是否有字符串重复，有重复则让它们引用一个相同的char[]</li></ol></li><li>优点：节省大量内存</li><li>缺点：略微多占用了cpu空间，新生代回收时间略微增加</li><li>与intern()的区别<ul><li>intern()关注的是字符串对象，G1关注的是底层的char[]</li><li>intern()是使用的StringTable</li></ul></li></ul><h4 id="JDK-8u40-并发标记时的类卸载"><a href="#JDK-8u40-并发标记时的类卸载" class="headerlink" title="JDK 8u40 并发标记时的类卸载"></a>JDK 8u40 并发标记时的类卸载</h4><ul><li>参数（默认打开）：-XX:+ClassUnloadingWithConcurrentMark</li><li>所有对象都经过并发标记后，就能知道哪些类不再使用，当一个<strong>类加载器的所有类都不再使用</strong>，则卸载它加载的所有类（适合写了自定义类加载器的框架程序）</li></ul><h4 id="JDK-8u40-回收巨型对象"><a href="#JDK-8u40-回收巨型对象" class="headerlink" title="JDK 8u40 回收巨型对象"></a>JDK 8u40 回收巨型对象</h4><ul><li>巨型对象：对象大小超过region的一半的对象</li><li>一个巨型对象可以占用好几个Region，用H表示</li><li>回收机制<ul><li>G1不会对巨型对象进行拷贝，G1进行GC时会优先考虑巨型对象</li><li>老年代中引用了巨型对象的卡也会被标记成脏卡</li><li>G1会跟踪巨型对象的老年代引用（即incoming引用），当某个巨型对象的老年代引用为0时，该对象就可以在<strong>新生代的垃圾回收</strong>中被回收掉</li></ul></li></ul><h4 id="JDK9并发标记起始时间调整"><a href="#JDK9并发标记起始时间调整" class="headerlink" title="JDK9并发标记起始时间调整"></a>JDK9并发标记起始时间调整</h4><ul><li>原因：并发标记必须在堆空间占满前完成，否则退化为Full GC，为减少Full GC发生几率，JDK9开始动态调整并发标记开始时间</li><li>JDK9之前：静态：-XX:InitiatingHeapOccupancyPercent（默认45%）<br>  该参数定大了会频繁发生Full GC，定小了会频繁做并发标记和混合收集</li><li>JDK9之后：动态调整阈值<ul><li>-XX:InitiatingHeapOccupancyPercent 设置初始值</li><li>进行数据采样并动态调整InitiatingHeapOccupancyPercent阈值</li><li>添加一个安全空档时间（容纳浮动垃圾）</li></ul></li></ul><h2 id="垃圾回收调优"><a href="#垃圾回收调优" class="headerlink" title="垃圾回收调优"></a>垃圾回收调优</h2><h3 id="查看与GC相关的虚拟机参数："><a href="#查看与GC相关的虚拟机参数：" class="headerlink" title="查看与GC相关的虚拟机参数："></a>查看与GC相关的虚拟机参数：</h3><p><code>-XX:+PrintFlagsFinal -version | findstr "GC"</code></p><h3 id="调优领域："><a href="#调优领域：" class="headerlink" title="调优领域："></a>调优领域：</h3><ul><li>GC：影响网络延迟</li><li>内存</li><li>io</li><li>CPU占用</li><li>锁</li></ul><h3 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h3><p>根据低延迟/高吞吐量，选择合适的回收器</p><ul><li>低延迟：CMS/<strong>G1</strong>/ZGC</li><li>高吞吐量：ParallelGC/G1</li></ul><h3 id="最快的GC是不发生GC（因为没有stw）"><a href="#最快的GC是不发生GC（因为没有stw）" class="headerlink" title="最快的GC是不发生GC（因为没有stw）"></a>最快的GC是不发生GC（因为没有stw）</h3><p>经常发生GC原因：</p><ul><li>数据太多？<br>  比如<code>resultSet = statement.executeQuery("select * from 大表")</code>数据太多导致堆内存频繁溢出，应在sql加一个<code>limit</code>限制数据个数</li><li>数据臃肿？<ul><li>数据库直接联查，查询了一些不用的东西</li><li>对象大小 比如使用了好多Integer，换成基本类型可以节约内存</li></ul></li><li>内存泄漏？<ul><li>定义了静态map，对于这种长时间存活对象可以采用软/弱引用，这种缓存的话可以借用第三方缓存实现</li></ul></li></ul><h3 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h3><ul><li>新生代特点<ul><li>所有new操作的内存分配都很廉价<ul><li>TLAB(thread-local allocation buffer)创建对象会先存入本地内存</li></ul></li><li>死亡对象回收代价是0（复制算法）</li><li>大部分对象用过即死</li><li>上边两点使得Minor GC的时间远低于Full GC</li></ul></li><li>调优方式<ul><li>把新生代调节的尽可能大：-Xmn（新生代初始和最大空间） 占到整个堆的25%-50%最佳<ul><li>太小：频繁回收</li><li>太大：老年代空间就小了，full gc将会频繁触发，会占用更长时间进行垃圾回收</li><li>调大原因：Minor GC主要耗费的时间在复制上，因为大部分对象用过即死，只有小部分存活，即只有小部分对象需要复制，所以即使新生代占了很大的空间，效率也不会下降到哪里去</li><li>新生代能容纳所有<code>并发量 * （请求响应过程中产生的对象）</code>的数据最佳</li></ul></li><li>幸存区调优<ul><li>要大到能保留<code>当前活跃的对象+需要晋升的对象</code><ul><li>原因：幸存区的内存太少可能会提前把存活时间短的对象晋升到老年代，等到full gc的时候才能把它回收，延长了没用对象的存活时间</li></ul></li><li>晋升阈值配置得当，让长时间存活对象尽快晋升<ul><li>原因：减少复制算法的时间</li></ul><pre><code>-XX:MaxTenuringThreshold=threshold //晋升阈值-XX:+PrintTeuringDistribution //在GC时显示幸存区的对象信息（年龄占用的空间数）</code></pre></li></ul></li></ul></li></ul><h3 id="老年代调优（CMS为例）"><a href="#老年代调优（CMS为例）" class="headerlink" title="老年代调优（CMS为例）"></a>老年代调优（CMS为例）</h3><ul><li>CMS的老年代内存越大越好<ul><li>预留更多的空间给并发时的用户线程，避免浮动垃圾引起的并发失败</li></ul></li><li>先尝试不做调优，如果没有full gc说明不用调，否则先尝试调优新生代</li><li>新生代条调过还不行，就观察发生full gc时老年代内存占用，看看是占用多大内存发生了full gc，在此基础上将老年代内存预设调大1/4~1/3</li></ul><pre><code>-XX:CMSInitiatingOccupancyFraction=percent //老年代空间占用percent时进行垃圾回收（一般75%-80%）</code></pre><h1 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h1><ul><li>是<strong>操作系统</strong>的内存而不是java内存，但可以被java内存直接访问</li><li>常用于NIO操作，用于数据缓冲区<ul><li>ByteBuffer.allocateDirect(int capacity)</li><li>如果不采用直接内存的话，要先从磁盘文件读到系统内存，再从系统内存读到Java堆内存</li></ul></li><li>分配和回收成本高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><h2 id="直接内存溢出问题"><a href="#直接内存溢出问题" class="headerlink" title="直接内存溢出问题"></a>直接内存溢出问题</h2><p>OOM: Direct buffer memory</p><h3 id="直接内存分配和回收原理"><a href="#直接内存分配和回收原理" class="headerlink" title="直接内存分配和回收原理"></a>直接内存分配和回收原理</h3><ul><li>直接内存的分配和回收是通过Unsafe类实现的，回收时需要主动调用freeMemory方法，而不是通过java垃圾回收实现</li><li>ByteBuffer的实现类内部，使用了Cleaner（虚引用）来监测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会由ReferenceHandler线程通过Cleaner的clean方法调用freeMemory来释放直接内存。</li></ul><blockquote><p>Cleaner<br>是一个虚引用对象，当该虚引用对象关联的ByteBuffer要被回收时，会触发Cleaner对象中的clean方法，clean方法执行一个任务对象，在任务对象中，会调用unsafe.freeMemory(long address)把直接内存的空间释放掉</p></blockquote><blockquote><p>-XX:+DisableExplicitGC：禁用显式垃圾回收<br>显示垃圾回收指的是代码的System.gc()，该方法会触发full gc，会对性能产生影响。<br>禁用显式垃圾回收的话<strong>对直接内存有影响</strong>，System.gc()被禁用后只有等到真正的垃圾回收发生时才会回收ByteBuffer，直接内存占据的空间才会被释放掉</p></blockquote><p>直接内存管理方式（释放）：利用反射机制获取Unsafe对象unsafe，通过unsafe.freeMemory(long address)释放本地内存。（long address是unsafe.allocateMemory(int capacity)的返回值）</p>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【知识记录】JVM知识记录（中）</title>
      <link href="/2022/09/26/0911-jvm/"/>
      <url>/2022/09/26/0911-jvm/</url>
      
        <content type="html"><![CDATA[<h1 id="运行时数据区概述及线程"><a href="#运行时数据区概述及线程" class="headerlink" title="运行时数据区概述及线程"></a>运行时数据区概述及线程</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>流程回顾：.class文件-&gt;类加载子系统-&gt;<strong>运行时数据区</strong>-&gt;执行引擎  </p><h3 id="JVM经典内存布局"><a href="#JVM经典内存布局" class="headerlink" title="JVM经典内存布局"></a>JVM经典内存布局</h3><p><img src="/../images/knowledge/jvm/JVM%E7%BB%8F%E5%85%B8%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt="JVM经典内存布局" title="JVM经典内存布局" loading="lazy"> </p><ul><li>本地方法栈、虚拟机栈、程序计数器：<br>一个线程对应一份，为线程私有</li><li>堆区、方法区：<br>一个虚拟机对应一份，由多个线程共享</li></ul><h3 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h3><p>单例的，一个虚拟机中只有一个实例，即运行时环境，相当于内存结构中的运行时数据区</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul><li>JVM允许一个应用有多个线程并行执行</li><li>HotSpot JVM里，每个线程都与OS的本地线程直接映射</li><li>一旦本地化线程初始化成功（建立程序计数器、栈等），本地线程就会调用Java线程中的run()方法。Java线程执行终止后，本地线程也会回收。</li></ul><h1 id="程序计数器（PC寄存器）"><a href="#程序计数器（PC寄存器）" class="headerlink" title="程序计数器（PC寄存器）"></a>程序计数器（PC寄存器）</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>是什么：</strong> JVM的PC寄存器是对物理PC寄存器的一种抽象模拟，用于<strong>存储指令相关的现场信息</strong>。<br><strong>作用：</strong> 用来<strong>存储指向下一条指令的地址</strong>。由执行引擎读取下一条指令。<br><strong>生命周期：</strong> 线程私有，与线程的生命周期保持一致。<br><strong>具体描述：</strong> 任何时间一个线程只有一个方法在执行，即当前方法。PC寄存器会存储<strong>当前线程正在执行的Java方法</strong>的JVM指令地址；如果正在执行native方法（用C/C++写的方法），则是未指定值（undefined）。<br><strong>其他</strong>：是唯一一个JVM规范中没有规定任何内存溢出（OutOfMemoryError，OOM）情况的区域。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><img src="/../images/knowledge/jvm/PC%E5%AF%84%E5%AD%98%E5%99%A8%E6%84%8F%E4%B9%89.png" alt="PC寄存器意义" title="PC寄存器意义" loading="lazy"> </p><h2 id="❤两个常见问题"><a href="#❤两个常见问题" class="headerlink" title="❤两个常见问题"></a>❤两个常见问题</h2><h3 id="使用PC寄存器存储字节码指令地址有什么用呢？-x2F-为什么使用PC寄存器记录当前线程的执行地址呢？"><a href="#使用PC寄存器存储字节码指令地址有什么用呢？-x2F-为什么使用PC寄存器记录当前线程的执行地址呢？" class="headerlink" title="使用PC寄存器存储字节码指令地址有什么用呢？/为什么使用PC寄存器记录当前线程的执行地址呢？"></a>使用PC寄存器存储字节码指令地址有什么用呢？/为什么使用PC寄存器记录当前线程的执行地址呢？</h3><p>因为CPU需要不停的切换各个线程，切换回来以后就得知道接着从哪开始继续执行。<br>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p><h3 id="PC寄存器为什么会被设定为线程私有？"><a href="#PC寄存器为什么会被设定为线程私有？" class="headerlink" title="PC寄存器为什么会被设定为线程私有？"></a>PC寄存器为什么会被设定为线程私有？</h3><p>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每个线程都分配一个PC寄存器，从而不会出现各线程之间互相干扰的情况。</p><h1 id="❤虚拟机栈"><a href="#❤虚拟机栈" class="headerlink" title="❤虚拟机栈"></a>❤虚拟机栈</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>栈是运行时的单位，堆是存储的单位<br><strong>是什么：</strong> Java虚拟机栈，早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，<strong>其内部保存一个个栈帧，对应着一次次的Java方法调用</strong>。<br><strong>作用：</strong> 主管Java程序运行，它保存方法的局部变量（8种基本数据类型、引用类型变量对应对象的引用地址）、部分结果，并参与方法的调用和返回。<br><strong>生命周期：</strong> 与线程相同。<br><strong>特点：</strong>   </p><ul><li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li><li>JVM直接对Java栈的操作只有两个：<ul><li>每个方法执行，伴随着<strong>进栈</strong></li><li>执行结束后的<strong>出栈</strong>工作</li></ul></li><li>栈不存在垃圾回收问题  <img src="https://jvm-lcc.oss-cn-beijing.aliyuncs.com/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E6%BC%94%E7%A4%BA.png" alt="虚拟机栈演示" width="100" align="middle" loading="lazy"></li></ul><p><strong>栈可能出现的异常：</strong><br>Java栈的大小是动态或固定不变的</p><ul><li>StackOverflowError：线程请求分配的栈容量超过Java虚拟机栈允许的最大容量。</li><li>OutOfMemoryError：虚拟机栈在尝试扩展时无法申请到足够的内存，或在创建新线程时没有足够的内存去创建对应的虚拟机栈，JVM会抛出该异常。</li></ul><p><strong>设置栈的内存大小：</strong><br>使用参数-Xss来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。<br><strong>其他：</strong> 存在OOM问题。</p><h2 id="栈的基本结构和运行原理"><a href="#栈的基本结构和运行原理" class="headerlink" title="栈的基本结构和运行原理"></a>栈的基本结构和运行原理</h2><p><strong>栈的结构</strong> </p><ul><li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<strong>当前栈帧</strong>，与当前栈帧相对应的方法就是<strong>当前方法</strong>，定义这个方法的类就是<strong>当前类</strong>。  </li><li>如果在当前方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈顶，成为新的当前帧。</li></ul><p><strong>栈运行原理</strong>  </p><ul><li>不同线程中所包含的栈帧不允许互相引用</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，JVM会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li><li>方法的两种结束方式：正常函数返回（return）和抛出异常（throw Exception，异常会抛给前一个栈帧）。两种结束方式都会导致栈帧被弹出。</li></ul><p><strong>❤栈帧的内部结构（五部分）</strong></p><ul><li><strong>局部变量表（LV）</strong><ul><li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用，以及returnAddress类型。</li><li><strong>不存在数据安全问题</strong>。原因：建立在线程的栈上，是线程的私有数据，不涉及共享。</li><li><strong>局部变量表所需的容量大小是在编译的时候确定下来的</strong>，并保存在方法的Code属性的maxinum local variables数据项中。方法运行期间是不会改变局部变量表的大小的。</li><li><strong>方法嵌套调用的次数由栈的大小决定</strong>。栈越大，方法嵌套调用次数越多。主要影响栈帧大小的是局部变量表。因此如果局部变量表越大，栈帧就越大，进而该方法调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li><li><strong>局部变量表中的变量只在当前方法调用中有效。当方法调用结束时，随着栈帧的销毁，局部变量表也会随之销毁。</strong></li><li><strong>槽（slot)</strong>:是局部变量表中最基本的存储单元，32位以内类型只占用一个slot(byte\short\char\boolean在存储前都会被转换成int)，64位的类型（double和long)占两个slot。  <ul><li>局部变量会<strong>按照顺序</strong>被复制到LV的每一个slot中。根据首地址（index）对局部变量进行访问。  </li><li>如果当前帧是由<strong>构造方法或实例方法</strong>创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。<em>（这条也就说明了为什么静态方法不能用this）</em></li><li><strong>slot的重复利用</strong>：栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位。举例：<br>  ![槽的重复利用](</li></ul></li></ul></li></ul><p><a href="https://jvm-lcc.oss-cn-beijing.aliyuncs.com/%E6%A7%BD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%88%A9%E7%94%A8.jpg">https://jvm-lcc.oss-cn-beijing.aliyuncs.com/%E6%A7%BD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%88%A9%E7%94%A8.jpg</a> “槽的重复利用”)<br>        <em>ps：实测当b或c为double时，槽也会复用</em><br>        - 补充说明：<br>            - 在栈帧中，与性能调优关系最为密切的就是LV表。<br>            - <strong>LV表中的变量也是重要的垃圾回收根节点，只要是LV表中直接或间接引用的对象都不会被回收</strong>。</p><pre><code>    &gt; 复习：变量的分类      1.按数据类型分：基本数据类型、引用数据类型      2.按在类中声明的位置分：成员变量（又细分为类变量（静态修饰）、实例变量（非静态修饰））、局部变量    &gt; 静态变量（类变量）、实例变量和局部变量的区别：      **静态变量**：在之前链接阶段中的准备阶段会被默认赋值，在初始化阶段会被显示赋值。       **实例变量**：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值。      **局部变量**：**在使用前，必须要进行显示赋值**，否则编译不通过。</code></pre><ul><li><p><strong>操作数栈（表达式栈）</strong></p><ul><li>在方法执行过程中，根据字节码指令，往栈中写入数据（入栈）或提取数据（出栈），操作数栈是由数组实现的。</li><li>操作数栈<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong>。</li><li>操作数栈就是JVM执行引擎的一个工作区，当一个方法开始执行的时候，一个新的栈帧也会随之被创建出来，<strong>这个方法的操作数栈是空的</strong>。</li><li>每一个<strong>操作数栈都会拥有一个明确的栈深度</strong>用于存储数值，其所需的<strong>最大深度在编译期就定义好了</strong>，保存在方法的Code属性中，为max_stack的值。</li><li><strong>若被调用的方法带有返回值，其返回值将会被压入当前栈帧的操作数栈中</strong>，并更新PC寄存器中下一条需要执行的字节码指令。</li><li>操作数栈中元素的数据类型与字节码指令的序列严格匹配，编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</li><li>32bit类型占用一个栈单位深度，64bit类型占用两个栈单位深度。</li><li>Java虚拟机的<strong>解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈。</li></ul><blockquote><p><strong>栈顶缓存技术</strong><br>  问题：栈式架构的JVM需要更多的指令分派次数和内存读/写次数。由于操作数是存储在内存中的，频繁的内存读/写操作会应援执行速度。<br>  解决：HotSpot提出栈顶缓存技术。即<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以降低对内存的读/写次数，提升引擎的执行效率</strong>。</p></blockquote></li><li><p>以下三部分（动态链接、方法返回地址、附加信息）也被合称为帧数据区</p></li><li><p><strong>动态链接（指向运行时常量池的方法引用）</strong></p><ul><li>在Java源文件被编译到字节码文件中时，所有变量和方法都作为符号引用保存在class文件的常量池里。</li><li>每一个栈帧内部都包含一个<strong>指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。</li><li>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</li></ul><blockquote><p>❤<strong>方法的调用：动态绑定、静态绑定</strong><br>  <strong>链接</strong>：静态链接、动态链接。=&gt;<strong>链接只针对方法</strong>。<br>  <strong>绑定</strong>：早起绑定、晚期绑定。绑定是一个<strong>字段、方法或者类</strong>在符号引用被替换为直接引用的过程，仅发生一次。<br>  方法的早期绑定（静态链接）：目标方法如果在编译期可知，且运行期保持不变，则可将这个方法与所属的类型进行绑定。<br>  方法的晚期绑定（动态链接）：如果被调用的方法在编译器无法被确定下来（如多态），只能在程序运行期根据实际的类型绑定相关的方法。</p></blockquote><blockquote><p>❤<strong>方法的调用：虚方法、非虚方法</strong><br>  <strong>非虚方法</strong>：方法在编译期就确定了具体的调用版本，这个版本在运行时不可变。包括所有不涉及到多态的方法：静态方法、私有方法、final方法、实例构造器、父类方法(super.xxx())<br>  <strong>虚方法</strong>：除上述方法之外的其他方法。 只要方法<strong>可能</strong>被重写，就都是虚方法，不管它现在有没有被重写。<br>  <em>子类对象的多态性的使用前提：1、类的继承关系 2、方法的重写</em><br>  <strong>JVM的方法调用指令：</strong><br>  1.非虚方法(不包括final)：invokestatic(针对静态方法)、invokespecial<br>  2.虚方法：invokevirtual、invokeinterface<br>  3.动态指令invokedynamic：jdk7加入，为了支持动态类型语言。<br>  4.特殊情况final：在子类调用父类的由final声明的方法时，指令为invokevirtual<br>  <em>动态语言与静态语言的区别：区别在于对类型的检测是在编译期还是运行期，举例：lambda表达式、python、JS</em></p></blockquote><blockquote><p><strong>方法的调用：方法重写的本质</strong><br>  1.找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C<br>  2.如果在类型C中找到与常量中的描述符（方法的参数列表和返回值）和简单名称都相符的方法，则进行访问权限校验。通过则返回这个方法的直接引用，查找过程结束；不通过则返回java.lang.IllegalAccessError异常。<br>  3.若未找到与常量中的描述符和简单名称都相符的方法，按照继承关系从下往上依次对C的各个父类进行第2步搜索和验证过程。<br>  4.如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常（即调用的方法还没有被实现，是个抽象方法）<br>  <strong>虚方法表</strong>：为了提高性能，JVM在类的方法区建立一个虚方法表（非虚方法不需要）来实现。使用索引表代替以上查找过程。每个类中都有一个虚方法表，存放各个方法的实际入口。虚方法表会在类加载的链接阶段（具体在解析阶段）被创建并开始初始化，类的变量初始值准备完成后，JVM会把该类的方发表也初始化完毕。</p></blockquote></li><li><p>方法返回地址（方法正常退出或异常退出的定义）<br>  为了好理解，假设A调用B</p><ul><li>存放调用该方法的PC寄存器的值（B的方法返回地址处存放A调用B后的下一条指令的PC计数器的值）</li><li>在方法退出后都返回该方法被调用的位置。<strong>方法B正常退出时，A的PC计数器的值作为返回地址，即调用B的指令的下一条指令的地址</strong>，方法B异常退出时，返回地址要通过异常表来确定，栈帧中一般不会保存这部分信息。</li><li><strong>正常完成出口和异常完成出口的区别</strong>：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</li><li>正常完成出口指令：ireturn(返回值为boolean\byte\char\short\int)、lreturn、freturn、dreturn、areturn(返回值为引用类型)、return(void方法、实例初始化方法<init>、类和接口的初始化方法<clinit>)</clinit></init></li></ul></li><li><p>一些附加信息<br>  允许携带与JVM实现有关的一些附加信息，但不一定有。例如：对程序调试提供支持的信息。</p></li></ul><h2 id="❤栈的相关面试题"><a href="#❤栈的相关面试题" class="headerlink" title="❤栈的相关面试题"></a>❤栈的相关面试题</h2><ol><li>举例栈溢出的情况？（StackOverflowError）<ul><li>通过-Xss设置栈的大小</li><li>栈大小固定会报栈溢出，栈大小可以动态调整可能会报OOM</li></ul></li><li>调整栈大小，就能保证不出现溢出吗？<br> 不能，比如要是整个死循环的递归还是会栈溢出。</li><li>分配的栈内存越大越好么？<br> 不是，会挤占别的线程的空间，可能会导致线程数变少。</li><li>垃圾回收是否涉及到虚拟机栈？<br> 不会。它只有进栈出栈，不要的栈帧直接出栈就行，不需要显示的回收。</li><li>方法中定义的局部变量是否涉及线程安全问题？<br> 具体问题具体分析。如果局部变量是在内部产生内部消亡的，就是线程安全的。如果不是内部产生的（比如某方法局部变量作为参数传递到了另一个方法），或者不是内部消亡的，生命周期没有结束（比如某方法的局部变量作为返回值传出去了），就是线程不安全的。</li></ol><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><p>作用：类似虚拟机栈，用于管理<strong>本地方法</strong>的调用。<br>具体做法：在本地方法栈中登记本地方法，在执行引擎执行时加载本地方法库。<br>特点：</p><ul><li>线程私有的</li><li>允许被实现成固定或是可动态扩展的内存大小。<br>内存溢出异常（同虚拟机栈）：<ul><li>StackOverflowError</li><li>OOM</li></ul></li><li>本地方法是C语言实现</li><li><strong>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限</strong>。<ul><li>本地方法可以通过本地方法接口<strong>访问JVM内部的运行时数据区</strong></li><li>可以直接使用本地处理器中的<strong>寄存器</strong></li><li>可以从本地内存的堆中分配任意数量的<strong>内存</strong></li></ul></li><li>并不是所有JVM都支持本地方法。只是HotSpot里有本地方法栈。在<strong>HotSpot中虚拟机栈和本地方法栈合二为一了</strong>。</li></ul><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="核心概述"><a href="#核心概述" class="headerlink" title="核心概述"></a>核心概述</h2><ul><li><strong>一个进程对应一个JVM实例，一个JVM实例只存在一个堆内存</strong>，堆也是Java内存管理的核心区域。</li><li>Java堆区在JVM启动的时候即被创建，其空间也就确定了。堆是JVM管理的最大一块内存空间。<ul><li>堆内存大小可以调节</li></ul></li><li>《Java虚拟机规范》规定，堆可以处于<strong>物理上不连续的内存空间，但在逻辑上是连续的</strong>。</li><li>所有线程共享Java堆，在这里还可以划分<strong>线程私有的缓冲区</strong>（Thread Local Allocation Buffer， TLAB（每个线程独有））。</li><li>“几乎”所有的对象实例以及数组都应当在运行时分配在堆上。</li><li>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。<br>  <img src="https://jvm-lcc.oss-cn-beijing.aliyuncs.com/%E5%A0%86%E4%B8%8Ejava%E6%A0%88.png" alt="堆与java栈" title="堆与java栈" loading="lazy"></li><li>方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</li><li>堆是垃圾回收的重点区域。</li><li>❤<strong>内存细分</strong>：<ul><li>Java7及以前堆内存逻辑上分为三部分：新生区+养老区+永久区<ul><li>新生区=新生代=年轻代<ul><li>伊甸园区</li><li>幸存者区</li></ul></li><li>养老区=老年区=老年代</li><li>永久区=永久代</li></ul></li><li>Java8及以后堆内存逻辑上分为三部分：新生区+养老区+元空间<ul><li>新生区=新生代=年轻代<ul><li>伊甸园区</li><li>幸存者区</li></ul></li><li>养老区=老年区=老年代</li><li>元空间</li></ul></li></ul></li></ul><h2 id="设置堆内存大小与OOM"><a href="#设置堆内存大小与OOM" class="headerlink" title="设置堆内存大小与OOM"></a>设置堆内存大小与OOM</h2><ul><li><p>-Xms：用于表示堆区的<strong>起始内存</strong>（年轻代+老年代），等价于-XX:InitialHeapSize</p><ul><li>-X是jvm的运行参数</li><li>ms是memory start</li><li>默认初试内存：物理电脑内存大小/64</li></ul><pre><code>  Runtime.getRuntime().totalMemory();</code></pre></li><li><p>-Xmx：用于表示堆区的<strong>最大内存</strong>（年轻代+老年代），等价于-XX:MaxHeapSize</p><ul><li>一旦堆区中的内存大小超过-Xmx所指定的最大内存，会抛<strong>OOM异常</strong></li><li>默认最大内存：物理电脑内存大小/4</li></ul><pre><code>Runtime.getRuntime().maxMemory(); </code></pre></li><li><p><strong>开发中建议把初始堆内存和最大堆内存设置成一样的值</strong>。因为频繁的扩容和释放会带来性能压力。</p></li><li><p>查看设置参数</p><ul><li>方式1：jps查进程-&gt;jstat -gc 进程id</li><li>方式2：-XX:+PrintGCDetails</li></ul></li><li><p>注意：虽然每一个幸存者区都被分配了内存，但是一般认为只有一个幸存者区放数据，因此java计算出来的分配给堆的内存会比实际分配给堆的内存少一些（只计算了一份幸存者区）。</p></li><li><p><strong>虚拟机可视化工具java VisualVM</strong></p></li></ul><h2 id="❤为对象分配内存：TLAB"><a href="#❤为对象分配内存：TLAB" class="headerlink" title="❤为对象分配内存：TLAB"></a>❤为对象分配内存：TLAB</h2><ul><li>对伊甸园区为每个线程分配私有的缓存区</li><li>作用：<strong>快速分配策略</strong>：多线程同时分配内存时，可以避免非线程安全问题，同时提升内存分配吞吐量。</li><li>尽管不是所有对象实例都能在TLAB中成功分配内存，但<strong>JVM确实是将TLAB作为内存分配的首选</strong>。</li><li>默认情况下，TLAB内存仅占整个伊甸园空间的<strong>1%</strong></li><li>一旦对象在TLAB空间分配内存失败，JVM就会尝试通过<strong>加锁机制</strong>确保数据操作的原子性，从而直接在伊甸园空间分配内存。</li><li>对象分配过程<br><img src="https://jvm-lcc.oss-cn-beijing.aliyuncs.com/TLAB%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.png" alt="TLAB对象分配过程" title="TLAB对象分配过程" loading="lazy"></li><li>相关参数<ul><li><code>-XX:UseTLAB</code> 设置是否开启TLAB空间（默认开启）</li><li><code>-XX:TLABWasteTargetPercent</code>设置TLAB空间占伊甸园空间的百分比大小</li></ul></li></ul><h3 id="面试题：堆空间一定是共享的吗？"><a href="#面试题：堆空间一定是共享的吗？" class="headerlink" title="面试题：堆空间一定是共享的吗？"></a>面试题：堆空间一定是共享的吗？</h3><p>不是，伊甸园区的TLAB是线程私有的。</p><h2 id="❤堆空间的参数设置"><a href="#❤堆空间的参数设置" class="headerlink" title="❤堆空间的参数设置"></a>❤堆空间的参数设置</h2><ul><li><p><code>-XX:+PrintFlagsInitial</code> 查看所有参数默认初始值</p></li><li><p><code>-XX:+PrintFlagsFinal</code> 查看所有参数最终值</p></li><li><p>具体查看某个参数的指令（如查看幸存区比例）：</p><ol><li><code>jps</code>：查看当前运行中的进程</li><li><code>jinfo -flag SurvivorRatio</code> 进程id</li></ol></li><li><p><code>-Xms</code> 用于表示堆区的<strong>起始内存</strong>（年轻代+老年代），等价于<code>-XX:InitialHeapSize</code>，默认初试内存：物理电脑内存大小/64</p></li><li><p><code>-Xmx</code> 用于表示堆区的<strong>最大内存</strong>（年轻代+老年代），等价于<code>-XX:MaxHeapSize</code>，默认最大内存：物理电脑内存大小/4  </p></li><li><p><code>-Xmn</code> 设置新生代的大小（初始值及最大值）</p></li><li><p><code>-XX:NewRatio</code> 设置新生代与老年代堆结构的占比（默认值2，新生代占1/3，老年代占2/3）</p></li><li><p><code>-XX:SurvivorRatio</code> 设置伊甸园区和幸存者区占比（默认值2）。</p><ul><li>伊甸园区偏大的话，会导致MinorGC后数据直接进入老年代，使MinorGC失去意义</li><li>幸存区偏大的话，MinorGC频率变高，stw变多，性能下降</li></ul></li><li><p><code>-XX:MaxTenuringThreshold=threshold</code> 晋升阈值（默认和垃圾回收器有关）</p></li><li><p><code>-XX:+PrintGCDetails</code> 输出垃圾回收的详细信息<br>  打印GC简要信息<br>  - <code>-XX:+PrintGC</code><br>  - <code>-verbose:gc</code></p></li><li><p><code>-XX:HandlePromotionFailure</code>：是否设置空间策略担保<br>  jdk7之后这个参数不会再影响到虚拟机的空间分配担保策略，相当于这个参数默认为true了，即：只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会Minor GC，否则将进行Full GC。</p></li></ul><h2 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h2><ul><li>jps工具：查看当前系统中有哪些Java进程</li><li>jmap工具：查看堆内存占用情况<pre><code># 查看某进程堆内存占用情况jmap -heap 进程id</code></pre></li><li>jconsole工具：可以连续监测，多功能监测，图形化界面<br>具体可以查看：内存占用、线程、类、CPU占用情况</li><li>举例：多次垃圾回收后内存占用依旧高，如何排查？</li></ul><ol><li>可以去jconsole执行一次JC，看看新生代和老年代的情况</li><li>使用jvisualvm 可视化虚拟机<br>使用监视-&gt;堆(dumnp) 截取堆信息快照进行分析（堆转储）。检查目前最大的对象，看看是哪个对象在占用内存。<br><a href="https://www.bilibili.com/video/BV1yE411Z7AP?p=21&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1yE411Z7AP?p=21&amp;spm_id_from=pageDriver</a></li></ol><h2 id="堆是分配对象存储的唯一选择吗？"><a href="#堆是分配对象存储的唯一选择吗？" class="headerlink" title="堆是分配对象存储的唯一选择吗？"></a>堆是分配对象存储的唯一选择吗？</h2><p>不是。</p><ul><li>如果经过逃逸分析后发现，<strong>一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。</li><li>TaoBaoVM的GCIH技术实现off-heap，<strong>将声明周期较长的Java对象从heap中移至heap外</strong>，并且GC不能管理GCIH内部的Java对象</li></ul><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><ul><li>JDK7后默认开启</li><li>分析对象动态作用域<ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被顶以后，它被外部方法所引用，则认为发生逃逸。（如作为参数传递到了其他方法里）</li></ul></li><li>结论：开发中能使用局部变量的，就不要使用在方法外定义</li></ul><h3 id="逃逸分析：代码优化"><a href="#逃逸分析：代码优化" class="headerlink" title="逃逸分析：代码优化"></a>逃逸分析：代码优化</h3><h4 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h4><p> 对没有逃逸出方法外的对象进行栈上分配。线程结束后，栈空间被回收，局部变量对象也被回收。这样无需进行GC了。</p><h4 id="同步省略（锁消除）"><a href="#同步省略（锁消除）" class="headerlink" title="同步省略（锁消除）"></a>同步省略（锁消除）</h4><ul><li>通过逃逸分析判断同步代码块所使用的的锁对象是否只能被一个线程访问而没有被发布到其他线程。</li><li>如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li></ul><h4 id="分离对象或标量替换"><a href="#分离对象或标量替换" class="headerlink" title="分离对象或标量替换"></a>分离对象或标量替换</h4><ul><li>标量：无法再分解成更小的数据的数据（如基本数据类型就是标量）。</li><li>聚合量：还可以再分解的数据，如Java对象就是聚合量。</li><li>有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在堆，而是存储在栈中。</li><li>举例：<br>  标量替换前：<br>  <img src="https://jvm-lcc.oss-cn-beijing.aliyuncs.com/%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2%E5%89%8D.png" alt="标量替换前" title="标量替换前" loading="lazy"><br>  标量替换后：<br> <img src="https://jvm-lcc.oss-cn-beijing.aliyuncs.com/%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2%E5%90%8E.png" alt="标量替换后" title="标量替换后" loading="lazy"></li></ul><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>所有JVM线程共享的区域</li><li>存储与类结构有关的信息<ul><li>运行时常量池</li><li>属性和方法数据</li><li>方法和构造器代码</li><li>构造器</li></ul></li><li>在虚拟机启动时被创建，<strong>逻辑上</strong>是堆的组成部分。<br><strong>在hotspot jdk1.8以前，方法区在堆的永久代中，1.8及以后放在了元空间中，用的是本地内存（OS的内存）</strong>，其中常量池的StringTable被移入了堆中。</li><li>方法区也会导致OOM<br><img src="/image/%E6%96%B9%E6%B3%95%E5%8C%BA%E8%AF%B4%E6%98%8E.png" title="方法区说明" loading="lazy"></li></ul><h2 id="内存溢出问题-OOM"><a href="#内存溢出问题-OOM" class="headerlink" title="内存溢出问题 OOM"></a>内存溢出问题 OOM</h2><p>类加载过多会导致内存溢出</p><ul><li>1.8以前 永久代内存溢出</li><li>1.8及以后 元空间内存溢出</li></ul><p>场景：  </p><ul><li>Spring利用cglib生成动态代理</li><li>Mybatis利用cglib产生实现类<br>cglib是在运行期间动态生成字节码完成动态类加载，代理技术里大量运用了这种生成技术，所以有可能导致永久代/元空间的OOM</li></ul><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>-XX:MaxPermSize 最大永久代内存大小（1.8以前）<br>-XX:MaxMetaSpaceSize 最大元空间内存大小（1.8及以后）</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>二进制字节码由三部分组成：类基本信息、常量池、类方法定义（虚拟机指令）  </p><ul><li>常量池：就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量（整数、bool等）等信息</li><li>运行时常量池：常量池是.class文件中的，<strong>当该类被加载，它的常量池信息就会被放入运行时常量池</strong>，并把符号引用（#1、#2之类的）变为真实地址</li></ul><h3 id="StringTable（串池）"><a href="#StringTable（串池）" class="headerlink" title="StringTable（串池）"></a>StringTable（串池）</h3><ul><li>举例<pre><code>String s1 = "a";String s2 = "b";String s3 = "ab"</code></pre><ul><li>变量拼接 false<pre><code>String s4 = s1 + s2;其内部实际上执行了(new StringBuilder).append("a").append("b").toString();StringBuilder的toString()实际上执行了：new String("ab"); 其实际创建了一个对象"ab"，结果存储在堆中因此s3 != s4</code></pre></li><li>字符直接拼接：编译期优化 true<pre><code>String s5 = "a" + "b";编译期直接被优化为String s5 = "ab"; 会直接去用串池中已有的字符串ab因此s3 == s5</code></pre></li></ul></li><li>串池特性：<ul><li><p>利用串池的机制（类似哈希表），来避免重复创建字符串对象</p></li><li><p>延迟加载：常量池中的字符串仅是符号，第一次使用才会变成String对象<br>  只有执行到相关指令时，字符串才会加载到串池中<br>  如执行到<code>String s1 = "a";</code>时才会把a加载到串池中</p></li><li><p>字符串<strong>变量</strong>拼接原理为StringBuilder（jdk1.8)</p></li><li><p>字符串<strong>常量</strong>拼接的原理是编译期优化</p></li><li><p>串池只存常量，不存动态拼接的结果</p></li><li><p>串池长度固定（即桶个数固定）</p></li><li><p>可以使用<strong>intern方法</strong>，主动将串池中还没有的字符串放入串池<br>  可以使用该方法将字符串对象尝试放入串池</p><ol><li>jdk1.8:<br> 如果串池<strong>有相同字符串</strong>则不会放入，原字符串引用指向的仍是堆中的对象<br> 如果<strong>没有</strong>则把当前对象的引用放入串池（常量池中不需要再存储一份对象了，可以直接存储堆中的引用）<br> 最后会<strong>把串池中的对象返回</strong><br> ❤举例1：原串池中没有相同字符串<pre><code>String s = new String("a") + new String("b"); //堆：new String("a")、new String("b")、new String("ab")（这个是StringBuilder创建）//串池："a"、"b"（没有"ab"，因为"ab"是变量拼接得到的）String s2 = s.intern();//串池："a"、"b"、"ab"System.out.println(s2 == "ab");//trueSystem.out.println(s == "ab");//true 注意这里！</code></pre> ❤举例2：原串池中有相同字符串<pre><code>String x = "ab";String s = new String("a") + new String("b"); //堆：new String("a")、new String("b")、new String("ab")（这个是StringBuilder创建）//串池："ab"、"a"、"b"String s2 = s.intern();System.out.println(s2 == "ab");//trueSystem.out.println(s == "ab");//true 注意这里！</code></pre></li><li>jdk1.6<br> 如果串池有相同字符串则同jdk1.8<br> 如果没有则<strong>会把此对象复制一份放入串池</strong>，原字符串引用指向串池中的字符串<br> 最后会把串池中的对象返回<br> ❤举例：原串池中没有相同字符串<pre><code>String s = new String("a") + new String("b"); //堆：new String("a")、new String("b")、new String("ab")（这个是StringBuilder创建）//串池："a"、"b"（没有"ab"，因为"ab"是变量拼接得到的）String s2 = s.intern();//s复制一份放入串池//串池："a"、"b"、"ab"System.out.println(s2 == "ab");//trueSystem.out.println(s == "ab");//false 注意这里！</code></pre></li></ol></li><li><p>StringTable位置</p><ul><li>1.6：是方法区常量池中的一部分，实际存储在永久代中</li><li>1.7及以后：从常量池中分离出来，原来的方法区放在了元空间中（1.8，1.7的方法区还在永久代），串池被放入堆中<br>  位置更改原因：永久代中只有full gc（老年代空间不足时才会触发）时才会回收，串池回收效率不高，会占用大量内存，导致永久代内存不足。</li></ul></li><li><p>StringTable垃圾回收</p><ul><li>一些参数<ul><li>-XX:PrintStringTableStatistics 打印串池统计信息</li><li>-XX:+PrintGCDetails 打印垃圾回收信息,可以详细了解GC中的变化</li><li>verbose:gc 显示GC的操作内容。可以显示最忙和最空闲收集行为发生的时间、收集前后的内存大小、收集需要的时间等。<br>  串池会触发垃圾回收，如果一些字符串没有被引用过，就会被回收掉。</li></ul></li></ul></li><li><p>StringTable性能调优</p><ol><li>-XX:StringTableSize=桶个数：调整<strong>哈希桶的个数</strong>，增大桶个数可以减少哈希冲突，不用去桶中查链表了，加快了哈希查找速度。如果系统中字符串常量个数很多，应适当加大桶的数量。</li><li>考虑是否将字符串对象入池：intern调优可以去重（比如好多用户都是重复地址，我用一个intern就可以在内存中只存一份地址），减少内存占用。</li></ol></li><li><p>特殊说明：</p><ul><li>在利用-Xmx:10m修改堆内存大小后，若字符串过多，不会报堆内存溢出，而是会报OOM:GC overhead limit exceeded。原因是开启了UseGCOverheadLimit(-XX:+UseGCOverheadLimit)，当GC时98%的时间都在进行垃圾收集，但只有不到2%的堆被回收掉时会触发此报错。如果要演示堆空间不足，需要把它关掉(-XX:-UseGCOverheadLimit)</li><li>1.7做出的改动只是把串池挪到堆中，永久代还没被完全删除</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文笔记】Leveraging Public-Private Blockchain Interoperability for Closed Consortium Interfacing</title>
      <link href="/2022/09/21/Interfacing/"/>
      <url>/2022/09/21/Interfacing/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>区块链尤其是通过允许利益相关者在一个去中心化的市场上进行互动以完成可信且公平的业务。目前<strong>私有链的局限在于其只适用于联盟内部，其中的数据和资产不能在私有链网络外进行交流</strong>。因此<strong>需要设计一个接口使得私有链中的数据在保证安全的同时能够与外界流通</strong>。</p><h3 id="接口设计挑战"><a href="#接口设计挑战" class="headerlink" title="接口设计挑战"></a>接口设计挑战</h3><ol><li>私有链中的参与者（business）和消费者可能有拜占庭行为，可能会入侵设备并且控制私有链中的联盟决策。</li><li>恶意business可能会优先执行有利可图的服务请求，影响系统公平性。</li><li>来自私有链内部的服务响应可能会泄露，需要保护数据隐私，此类响应数据应只能由请求它的用户可见。</li></ol><h3 id="contribution"><a href="#contribution" class="headerlink" title="contribution"></a>contribution</h3><ol><li>通过公有链+私有链设计去中心化接口，使得两个链之间有互操作性，以支持可信和安全的数据传输。</li><li>设计Consensus on Consensus共识机制，使得数据可以从公网安全并可验证的传到私有链。</li><li>基于签名收集（CoSi）技术设计机制，从私有链的联盟中生成可验证的结果，使得消费者可以安全访问该结果。</li></ol><h2 id="System-Model"><a href="#System-Model" class="headerlink" title="System Model"></a>System Model</h2><ol><li>接收的消息无序或丢失</li><li>Threat Model<ul><li>拜占庭参与者</li><li>针对私有链进行女巫攻击</li><li>针对消费者进行假冒攻击</li><li>敏感信息泄露</li></ul></li></ol><h2 id="设计原理和挑战"><a href="#设计原理和挑战" class="headerlink" title="设计原理和挑战"></a>设计原理和挑战</h2><h3 id="接口的两点保证"><a href="#接口的两点保证" class="headerlink" title="接口的两点保证"></a>接口的两点保证</h3><ol><li><strong>保证安全（Consortium Interface Safety）</strong>：该接口应确保所有真的私有链成员以相同的顺序同意同一组传入的消费者请求。（解决消息无序、拜占庭参与者、假冒攻击）</li><li><strong>保证活性（Consortium Interface Liveness）</strong>：该接口应确保封闭联盟最终会处理并提交所有真的消费者请求。（解决女巫攻击）</li></ol><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>利用<strong>公有链平台作为接口</strong>支持私有链中的封闭联盟同公网的消费者进行通信。公链的共识算法能够抵抗女巫攻击，且接收到的消费者请求是有序的。</p><h3 id="组合公私链的挑战"><a href="#组合公私链的挑战" class="headerlink" title="组合公私链的挑战"></a>组合公私链的挑战</h3><ol><li>共识信息在两种链上应相互可验证。</li><li>在公链上应对从私有链传出的敏感信息进行数据保护。</li><li>私链中的联盟决策应在客户端可验证。</li></ol><h2 id="去中心化联盟接口详细设计"><a href="#去中心化联盟接口详细设计" class="headerlink" title="去中心化联盟接口详细设计"></a>去中心化联盟接口详细设计</h2><h3 id="消费者请求传给私有链（两轮共识）"><a href="#消费者请求传给私有链（两轮共识）" class="headerlink" title="消费者请求传给私有链（两轮共识）"></a>消费者请求传给私有链（两轮共识）</h3><ol><li><p>公链上的常规共识</p><ol><li>消费者通过公链发送请求，这些请求作为一个交易形成用户请求合约（User Request Contract），部署在公链上。</li><li>通过公链平台的挖掘/共识过程（PoW之类的），将“消费者请求”交易提交到账本中的一个区块上。</li><li>一旦一个区块被开采并提交到公共区块链中，这将确保对特定区块及其提交顺序达成共识，因为每个区块都通过其加密哈希值与前一个区块相连。</li></ol></li><li><p>Consensus on Consensus<br> 两轮共识原因：单公链共识不能保证Consortium Interface Safety（封闭联盟无法获得请求、恶意联盟成员、公链共识可能会导致请求冲突）<br> 原理：<strong>联盟成员加入公链，代表自己称为可信代理</strong></p><ol><li>成员自己通过SPV验证公链上的交易</li><li>当有新区块提交到公链上时，与成员相关的可信代理获取事件触发器，调用私有链中的传播合约。</li></ol><h4 id="传播合约"><a href="#传播合约" class="headerlink" title="传播合约"></a>传播合约</h4><p> 任务：从每个成员那里对每条消费者请求收集可验证的背书  </p><blockquote><p>背书就是成员的数字签名证书，表明相关成员同意提交到公链上的消费者请求。</p></blockquote><p> 该过程通过标准BFT来收集签名并完成。<br> 传播合约会触发调度合约，当请求在私有链中被调度和处理，结果就会被返回给消费者</p></li></ol><h3 id="私有链响应传给消费者"><a href="#私有链响应传给消费者" class="headerlink" title="私有链响应传给消费者"></a>私有链响应传给消费者</h3><p>两种消息类型：</p><ol><li>联盟（节点）信息</li><li>请求响应</li></ol><p>这两种消息都在私有链的共识过程中产生，且不应在私有链以外的地方修改。<br>目标：</p><ol><li>使私有链外的消费者可以验证相应消息</li><li>请求响应信息的隐私保护</li></ol><p>做法：使用收集签名（CoSi）机制保证信息可验证。</p><ul><li>BLS签名</li><li>利用BLS发送信息<br>  信息通过私有链的协作合约产生。结果数据必须收集到至少2/3的成员签名。<ol><li>由一个私有链成员提出信息，生成签名请求消息$Signing-Request$</li><li>将签名请求消息转发给其他联盟成员</li><li>每个联盟成员收到消息后添加自己的签名</li><li>当聚合了2/3以上成员签名，最终的消息${I, H(I), B, [H(I)_{S_B}]}$会发给公链。</li><li>消费者客户端只接收签名数量&gt;2/3的消息<br>  私有信息隐私保护：在响应流程的基础上，对消息进行加密（$I$ -&gt; $<m>_{P_u}$），加密用的是相应特定消费者的公钥</m></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链, 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文笔记】Gosig A Scalable and High-Performance Byzantine Consensus for Consortium Blockchains</title>
      <link href="/2022/09/21/0912-gosig/"/>
      <url>/2022/09/21/0912-gosig/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>提出了一个快速、可扩展、分布式的BFT系统，该系统通过融合协议和底层Gossip网络来解决以下三个挑战：</p><ol><li>单点故障</li><li>有限带宽和高延迟</li><li>最慢节点限制整个处理流程</li></ol><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="共识协议"><a href="#共识协议" class="headerlink" title="共识协议"></a>共识协议</h4><p>Gosig分轮运作，每轮都在区块链上附加一个区块。每轮包括两个阶段：</p><ol><li>区块提出阶段<ol><li>随机选择若干提出者</li><li>每个提出者打包交易到新区块并广播该区块到所有其他节点。</li></ol></li><li>签名收集阶段<ol><li>每个节点选出一个在上阶段收到的区块并投票，为它的决策签名</li><li>不断转发由自己签署并从其他方收到的聚合签名。</li><li>如果一个节点收集了足够的签名，表明没有冲突的区块可以被提交，那么这个节点就会提交一个区块。</li></ol></li></ol><h4 id="Gossip网络"><a href="#Gossip网络" class="headerlink" title="Gossip网络"></a>Gossip网络</h4><p>Gosig使用gossip网络来传播所有消息。共识协议确保同一阶段的消息在gossiping期间能被高效聚合。</p><h4 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h4><p>为每个新区块<strong>随机选举proposer</strong>来对所有可能的进程进行管道化处理，并使用基于gossip的广播汇总所有签名。<br>优点：</p><ol><li><strong>替换proposer安全且开销小</strong>，可以解决挑战一。<ul><li>利用VRF（可验证随机函数）选举proposer使得选择随机且不可预见。</li><li>消除标准PBFT中开销大的ViewChange。<br>  利用了一个提议者在其选举回合中最多提出一个区块的事实，并通过<strong>在每个提议中携带一个小证明</strong>来证明新提议者的有效性，实现了零开销的提议者替换。该协议在同步回合中进行，在一个回合中最多可以提交一个区块。</li></ul></li><li>优化签名收集，解决挑战三<br> 将多个接收的签名组合到一个等效的聚合签名中并转发该汇总签名。对多签名数据结构进行扩展，以允许任意的签名顺序，这样一组聚合的签名可以在gossip中再次聚集。<br> 签名聚合使签名信息的大小减少了两个数量级，并大大减少了签名收集阶段的总数据传输。更重要的是，这种减少是在所有参与者中均匀实现的，防止任何单节点能力成为瓶颈。</li><li>所有级别的流水线传输<br> 在聚合签名后，投票交换是有延迟限制的，当每个参与者在等待投票进展时，网络带宽没有被充分利用。Gosig在Gossip层和BFT投票层进行流水线处理，以最大限度地提高网络利用率。</li></ol><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p> 每个节点向其他节点转发交易，并在以后按特定顺序将它们打包成区块。所有提交的区块被序列化成区块链，并被复制到所有节点。在区块链中，一个区块通过包含前一个区块的哈希值来扩展链。当且仅当一个区块包含的交易被提交时，该交易才被确认。Gosig作为共识协议来保证所有区块链的副本都是相同的。</p><h3 id="系统模型和假设"><a href="#系统模型和假设" class="headerlink" title="系统模型和假设"></a>系统模型和假设</h3><h4 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h4><ol><li>系统中有超过$N=3f+1$个节点，至多$f$个节点出现拜占庭故障，其他$2f+1$个节点能正确工作。</li><li>节点能通过可信的PKI（公钥基础设施）鉴别其他节点的身份。</li></ol><h4 id="保证"><a href="#保证" class="headerlink" title="保证"></a>保证</h4><ol><li>允许f个有问题的节点被对手自适应地破坏掉。</li><li>保证在异步网络中的安全以及在局部同步网络中的活性</li><li>活性属性还需要一个松散的同步时钟，理论上可以用部分同步假设来建立，在实践中也由网络时间协议（NTP）提供。即使时钟有任意的偏差，也不会影响安全性。Gosig还提供了有效性属性，即所有承诺的事务都遵循一些应用层面的预定义的验证规则。</li></ol><h3 id="Gosig协议概述"><a href="#Gosig协议概述" class="headerlink" title="Gosig协议概述"></a>Gosig协议概述</h3><p>将Gosig的执行分为具<strong>有固定时间长度</strong>的几轮。每轮包含proposer选择阶段（无通信）和随后的两个有固定长度的阶段。因此，所有节点能通过<strong>参考本地时钟得知当前轮数和阶段</strong>。每轮流程如下图所示：<br><img src="/../images/paper/Gosig/gosig_round.png" alt="Gosig round" title="Gosig round" loading="lazy"></p><ol><li>在每一轮的开始时，一些节点通过加密的排序算法（见后文）意识到他们是这一轮的潜在proposer。但它不知道别的潜在proposer。因此，对抗者无法找到proposer（除非随便猜猜到了）。</li><li>阶段1：每个潜在的proposer将非冲突的未提交的交易打包在一个区块提案中，通过gossip分发出去，该proposer之后的行为就像一个正常的节点一样。</li><li>阶段2：通过投票交换在本轮对一些区块提案达成共识。<br>一个节点通过在区块的准备消息（”$P$ message”）中添加自己的数字签名来为该区块投票，然后通过gossip传播该区块。<strong>一个诚信的节点每轮只为一个提案投票</strong>。<br>直到一个区块的$P$ message收到至少$2f+1$个签名时，节点通过在其本地状态中存储消息和轮次，对该块进行暂定提交，并开始 为其发送暂定提交消息（”$TC$ message”）。<br>当该节点收到$2f+1$条$TC$ messages时，将区块提交到它的本地区块链副本上。如果它最终在相同轮次提交区块失败，本地状态会用来决定决定是否接受新的提案，或决定在下一步中提出哪个区块。</li></ol><h2 id="Gosig协议设计"><a href="#Gosig协议设计" class="headerlink" title="Gosig协议设计"></a>Gosig协议设计</h2><h3 id="消息和状态定义"><a href="#消息和状态定义" class="headerlink" title="消息和状态定义"></a>消息和状态定义</h3><p>除了区块链副本外，每个节点还有一个本地状态，并基于这个状态和外部事件（接收一个确切的消息或被选为proposer）决定它的下个动作。<br><img src="/../images/paper/Gosig/notations.png" alt="Notations" title="Notations" loading="lazy"><br>当Gosig开始运行时，节点的本地状态被初始化为$s_i=&lt;null, 0, null&gt;$。当一个区块最终被提交，该区块会被添加到区块链上且节点的本地状态会重置。</p><h3 id="阶段1：区块提出"><a href="#阶段1：区块提出" class="headerlink" title="阶段1：区块提出"></a>阶段1：区块提出</h3><h4 id="Proposer选择方法"><a href="#Proposer选择方法" class="headerlink" title="Proposer选择方法"></a>Proposer选择方法</h4><p>使用VRF来选择一组潜在的proposer。</p><ol><li><p>随机种子$Q^h$<br> <img src="/../images/paper/Gosig/eq1.png" alt="公式1" title="公式1" loading="lazy"><br> $Q^0$是所有节点共享的随机值。</p></li><li><p>proposer分数$L^r(i)$<br> 根据随机种子$Q^h$可得$L^r(i)=H(SIG(r, Q^h))$。$h$是第$r$轮区块链的长度。<br> 若节点的proposer分数小于proposer阈值，那么它就会被选为潜在的proposer。阈值被设置为$7/N$，$N$为节点的总数。在每一轮开始时，每个节点$p_i$计算它的$L^r(i)$，进而得知它是否是本轮潜在的proposer。  </p></li><li><p>潜在proposer证明<br> 根据proposer证明$SIG_i(r, Q^h)$，一个潜在的proposer能向其他节点证明它的proposer状态。这个过程无需和其他节点通信。</p></li></ol><h4 id="区块提出"><a href="#区块提出" class="headerlink" title="区块提出"></a>区块提出</h4><ol><li><p>每个潜在提出者$p_i$决定提出哪个区块，然后生成一个提案消息。如果$p_i$已经暂时提交了一个区块$B_tc$，则$B_tc$将被提出，否则$p_i$会生成一个新区块。</p></li><li><p>潜在的提出者会为提出的区块$B$提供一个提案证书以保证提案的有效性。</p><ul><li>如果提出者选的$B$是$B_tc$，那提案证书是一个$P$-证书。</li><li>如果提出者选的是一个新区块，那提案证书提交到区块链的最后一个区块的$TC$-证书。</li></ul><p> 如表1定义所示，提案证书轮次$c.r$将被用来说服其他已经暂时提交了早期区块的节点重置它们的状态并准备区块B。这个证书至少被$2f+1$给节点签名，因此不可被伪造。</p></li><li><p>最后，潜在提出者$p_i$组装一个$PR$消息，如表1所示。然后$p_i$用私钥为消息签名。<br>每个节点通过检查$PR$消息包含的区块、签名和证书能轻松验证$PR$消息有效性。<br>当节点收到一个提案，它会检查提案的高度是否和节点本地已提交的区块链高度吻合。如果某些已提交的区块在某个节点上丢失，该节点会等到所有丢失区块异步恢复后再投票（恢复流程见下节）。</p></li></ol><h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>在阶段1期间，通过八卦向所有节点广播PR消息。在阶段1末尾（在固定时间后），大多数节点应该都能看见本轮中所有被提出的区块。</p><h3 id="阶段二：签名收集"><a href="#阶段二：签名收集" class="headerlink" title="阶段二：签名收集"></a>阶段二：签名收集</h3><p>目标：分发节点对区块提案投票的签名消息。使用八卦来传播所有消息。</p><h4 id="阶段二协议"><a href="#阶段二协议" class="headerlink" title="阶段二协议"></a>阶段二协议</h4><p>将每个节点$p_i$建模为有限状态机。节点基于它当前的本地状态和输入消息来执行动作。<br><img src="/../images/paper/Gosig/algo1.jpg" alt="算法1" title="算法1" loading="lazy"><br><img src="/../images/paper/Gosig/algo2.png" alt="算法2" title="算法2" loading="lazy"></p><ol><li><p>初始化阶段<br> 节点检查它在阶段1接收的所有区块提案，通过DecideBlock算法（算法2）决定准备哪个区块。<br> 算法2的思想是趋向于选择认证轮次大的区块提案。区块认证轮次大，区块越新。</p></li><li><p>处理输入消息</p><ul><li><p>接收到合法$P_X^r(B)$消息  </p><ul><li>当阶段为$P_{ed}$，且收到的消息中区块为$\bar{B}$：<br>  根据聚合签名$P_X^r(B)$更新$SigP$。<br>  当它从$\bar{B}$的$P$消息中收集了至少$2f+1$个签名后将阶段修改为$TCed$，暂时提交$\bar{B}$到本地。开始八卦签名$SigTC$。</li></ul></li><li><p>接收到合法$TC_X^r(B)$消息</p><ul><li>阶段不为$Init$，且收到的消息中区块为$\bar{B}$：<br>  根据聚合签名$TC_X^r(B)$更新$SigTC$。<br>  当它从$\bar{B}$的$TC$消息中收集了至少$2f+1$个签名后将阶段修改为$Ced$，带着证书$SigTC$提交$\bar{B}$。</li></ul></li></ul></li></ol><p>当区块被提交或者恢复所有已提交区块时，节点的本地状态将重置。</p><h2 id="关键性能优化"><a href="#关键性能优化" class="headerlink" title="关键性能优化"></a>关键性能优化</h2><h3 id="传输流水线：解决挑战2"><a href="#传输流水线：解决挑战2" class="headerlink" title="传输流水线：解决挑战2"></a>传输流水线：解决挑战2</h3><p>允许独立的块和消息交换尽可能地异步运行，以减少节点的等待时长，并利用空闲带宽。</p><h4 id="流水线友好的块结构"><a href="#流水线友好的块结构" class="headerlink" title="流水线友好的块结构"></a>流水线友好的块结构</h4><p>区块由三部分组成：</p><ul><li>header：包含所有元数据，如证书、提案证明</li><li>body：排好序的交易哈希<br>  可以被分段，类似于比特容忍转发文件，允许节点在接收到完整区块body前开始发出数据。<br>  与比特容忍文件不同的是，<strong>提出者在八卦分段之前为每个分段都签了名</strong>。这步很重要，若没有这步的话，对手能生产很多垃圾分段来干扰网络。</li><li>区块中的原始交易</li></ul><h4 id="各阶段间的流水线"><a href="#各阶段间的流水线" class="headerlink" title="各阶段间的流水线"></a>各阶段间的流水线</h4><ol><li>在传播body和原始交易前，八卦网络会先传播区块header<br> 一个节点只需要传播区块头部，其他节点就能根据算法2做选择。原因见算法2第四行和提案者分数计算方法，计算只用到了header里的签名。</li><li>在确保所有节点都收到了headers（阶段1的超时时间确保所有节点收到），开始阶段2</li></ol><p>由于头部很小，因此该优化大幅度减少了阶段1的时间。此外，由于节点更早的接收到了区块header，它们能尽早决定提案者，而不需要浪费带宽去传递其他提案者“没用”的区块内容。</p><h4 id="异步的原始消息传播"><a href="#异步的原始消息传播" class="headerlink" title="异步的原始消息传播"></a>异步的原始消息传播</h4><ul><li>随后八卦网络传播区块体。<br>  body里用6字节短哈希代替32字节的SHA256哈希，除非出现哈希冲突。因此body也比所有原始交易的总和小得多。</li><li>对原始交易进行异步八卦<ul><li>当节点收到了以前没见过的交易，它会将交易传给一些随机节点（默认3个）。</li><li>如果节点在收到原始交易前可能见过该区块的body，它会在节点处理（即暂定提交）之前，从其他随机的节点中检索出丢失的交易的区块。<br>  为找到区块，节点节点将3字节的索引送入区块，而不是6字节的短哈希。这里的优化可以参考<a href="https://github.com/bitcoin/bips">bips</a>。</li><li>要求节点接收区块body，聚集所有相关的原始交易，并在阶段2更新本地状态和发出TC消息前对原始交易进行验证。</li></ul></li></ul><h3 id="轮次间的流水线"><a href="#轮次间的流水线" class="headerlink" title="轮次间的流水线"></a>轮次间的流水线</h3><pre><code>如果节点是潜在提出者，它在提出新区块后就可以开始下一轮了，不用等别的节点提交。</code></pre><h3 id="任意顺序的聚合签名：解决挑战3"><a href="#任意顺序的聚合签名：解决挑战3" class="headerlink" title="任意顺序的聚合签名：解决挑战3"></a>任意顺序的聚合签名：解决挑战3</h3><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><p>一个节点$p_i$的加密签名包括哈希函数$H$，公钥生成器$G$，私钥$x_i$和公钥$V_i=G^{x_i}$。一个节点用私钥对消息$M$进行签名，即签名$S_i=H(M)^{x_i}$。其他人能通过检查$e(G,S_i) = e(V_i,H(M))$是否成立来验证签名，$e$是一个给定的双线性映射。</p><blockquote><p><a href="https://blog.csdn.net/CCCYYY090/article/details/116660613">BLS安全性证明</a></p></blockquote><p>为跟踪收到的签名，在签名中添加了大小为$N$的整数数组$n$。在节点$p_i$对消息签名时（即$S_i=H(M)^{x_i}$），对$S_i$数组$n_{S_i}$的第$i$个元素+1。因此聚合签名为$(S_i,n_{S_i})$。</p><blockquote><p>为什么要跟踪收到的签名？<br>我的理解：采用Gossip协议无法确定已聚合的签名来自哪里，有可能存在来自自己的签名，导致一个节点对一个信息进行了多次签名。因此需要用一个数组来记录这个节点对消息进行了多少次签名。此外，可以通过判断数组不为0的元素个数来确定有多少节点对该消息进行了签名。<br>具体详见《Keeping Authorities “Honest or Bust” with Decentralized Witness Cosigning》的IV.E</p></blockquote><p>聚合签名通过将BLS签名相乘和数组n相加实现，即聚合签名为$S=H(M)^{\sum_{i}{x_i·n_s{[i]}}}$。假设有两个聚合签名$(S_1,n_{S_1})$和$(S_2,n_{S_2})$，将两个签名合并为$(S_1*S_2, n_{S_1}+n_{S_2})$。因此聚合签名验证方法为判断$e(G,S)=e(\prod_i{V_i^{n_S[i]}, H(M)})$是否成立。</p><h4 id="数组压缩"><a href="#数组压缩" class="headerlink" title="数组压缩"></a>数组压缩</h4><ol><li>使用变长整数编码来编码，将大多数元素的大小缩减到2位</li><li>如果签名的人不多（数组里有好多0），Gosig利用稀疏性将其编码在一个map中</li><li>进一步进行整数数组压缩[34]</li></ol><h3 id="持续性八卦"><a href="#持续性八卦" class="headerlink" title="持续性八卦"></a>持续性八卦</h3><p>每个节点向在阶段2有限个随机邻居（默认5个）发送P消息或TC消息，有限的连接帮助避免转发签名过于激进而失去聚合机会。<br>如果一些签名没有被及时处理，那么节点会把消息放在栈里。之所以用栈而不是队列，是因为消息到达的越晚意味着消息包含更多的签名。</p><h2 id="处理特殊情况"><a href="#处理特殊情况" class="headerlink" title="处理特殊情况"></a>处理特殊情况</h2><h3 id="参与者加入和离开"><a href="#参与者加入和离开" class="headerlink" title="参与者加入和离开"></a>参与者加入和离开</h3><p>存在的节点会在提交交易是更新他们子集的参与者列表。</p><h3 id="处理暂时的失败"><a href="#处理暂时的失败" class="headerlink" title="处理暂时的失败"></a>处理暂时的失败</h3><p>如果一个节点数据丢失/崩溃，它应该查询所有丢失的区块和证明。它只有恢复完整的历史记录后才能继续参加投票。<br>如果节点探测到他的邻居有连接问题，它会在$T_o$（一般是一轮投票的一半时间）期间暂停对该邻居发送消息。若过了这段时间后还是连接失败，它会动态增加$T_o$。这个过程一直重复到它收到了该邻居的消息。这个机制有效的限制了因尝试连接失效节点导致的浪费。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链, 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【知识记录】JVM知识记录（上）</title>
      <link href="/2022/09/10/0904-jvm/"/>
      <url>/2022/09/10/0904-jvm/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟机概述"><a href="#虚拟机概述" class="headerlink" title="虚拟机概述"></a>虚拟机概述</h1><h2 id="虚拟机分类"><a href="#虚拟机分类" class="headerlink" title="虚拟机分类"></a>虚拟机分类</h2><p>系统虚拟机（VMware等)和程序虚拟机（Java虚拟机）<br>系统虚拟机：对物理计算机的仿真，提供可运行完整OS的软件平台。<br>程序虚拟机：专门为执行单个计算机程序而设计。</p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="JVM-跨语言虚拟机，用于执行字节码。"><a href="#JVM-跨语言虚拟机，用于执行字节码。" class="headerlink" title="JVM:跨语言虚拟机，用于执行字节码。"></a>JVM:跨语言虚拟机，用于执行字节码。</h3><p>只要编译的字节码文件符合字节码规范，都可使用JVM。因此java字节码也可以称为<strong>JVM字节码</strong>。<br><img src="/../images/knowledge/jvm/JVM%E8%B7%A8%E8%AF%AD%E8%A8%80%E5%B9%B3%E5%8F%B0.png" alt="JVM跨语言平台" title="JVM跨语言平台" loading="lazy"></p><h3 id="JVM特点"><a href="#JVM特点" class="headerlink" title="JVM特点"></a>JVM特点</h3><ul><li>一次编译，到处运行</li><li>自动内存管理</li><li>自动垃圾回收功能</li></ul><h3 id="JVM位置"><a href="#JVM位置" class="headerlink" title="JVM位置"></a>JVM位置</h3><p><img src="/../images/knowledge/jvm/JVM%E4%BD%8D%E7%BD%AE.png" alt="JVM位置" title="JVM位置" loading="lazy"></p><h3 id="♥JVM整体结构"><a href="#♥JVM整体结构" class="headerlink" title="♥JVM整体结构"></a>♥JVM整体结构</h3><p>整体结构需要会画<br>HotSpot虚拟机内存结构图如下：<br><img src="/../images/knowledge/jvm/JVM%E7%BB%93%E6%9E%84.png" alt="JVM结构" title="JVM结构" loading="lazy"></p><h3 id="JVM架构模型"><a href="#JVM架构模型" class="headerlink" title="JVM架构模型"></a>JVM架构模型</h3><p>HotSpot是基于<strong>栈的指令集架构</strong>  </p><ul><li>基于栈的指令集架构  <ul><li>设计实现简单 适用于资源受限系统</li><li>避开寄存器分配难题</li><li>指令大部分是零地址指令，其执行过程依赖于栈，<strong>指令集小（但指令多）</strong>，编译器容易实现</li><li>不需要硬件支持，<strong>可移植性好</strong></li><li><strong>执行性能比寄存器差</strong></li></ul></li><li>基于寄存器的方式<ul><li>典型应用：x86二进制指令集：传统PC、安卓的Davlik虚拟机</li><li>性能优秀，执行高效</li><li>指令集架构完全依赖硬件，可移植性差</li><li>花费更少的指令完成一项操作</li><li>以一地址指令、二地址指令、三地址指令为主</li></ul></li></ul><h3 id="JVM生命周期"><a href="#JVM生命周期" class="headerlink" title="JVM生命周期"></a>JVM生命周期</h3><p><strong>启动-&gt;执行-&gt;退出</strong></p><ol><li>虚拟机的启动<br>通过引导类加载器创建一个初始类（init class）来完成的，这个类是由虚拟机的具体实现指定的。<br><em>ps:用户自定义类加载器-&gt;系统类加载器-&gt;扩展类加载器-&gt;引导类加载器</em></li><li>虚拟机的执行<br>程序开始执行时才运行，程序结束时他就停止<br><strong>执行一个Java程序的时候，真正执行的是一个叫做Java虚拟机的进程</strong></li><li>虚拟机的退出<br>退出情况：正常结束、异常终止、OS错误导致JVM进程终止、Java代码中主动结束（exit()、halt())</li></ol><h3 id="JVM发展历程"><a href="#JVM发展历程" class="headerlink" title="JVM发展历程"></a>JVM发展历程</h3><ol><li>Sun Classic VM  <ul><li>第一款商用虚拟机、1.4淘汰</li><li>只提供解释器没有JIT即时编译器（效率低）</li><li>JIT编译器可以外挂但不能和解释器同时使用</li></ul></li><li>Exact VM  <ul><li>准确式内存管理（Exact Memory Management):<br> VM可以知道内存中某个位置的数据具体是什么类型（数据还是地址）  </li><li>编译器和解释器可以混合工作、可以热点探测</li><li>只在Solaris平台短暂使用，其他平台还是Sun Classic VM</li></ul></li><li><strong>HotSpot VM</strong> <ul><li>有影响力的三大商用虚拟机之一</li><li>JDK6和JDK8的默认虚拟机、Sun/Oracle JDK和OpenJDK的默认虚拟机  </li><li>方法区概念只有HotSpot有  </li><li>HotSpot指的是热点代码探测技术  <ul><li>通过计数器找到最具编译价值的代码，触发即时编译或栈上替换</li><li>通过编译器和解释器协同工作，在最优化的程序时间与最佳执行性能中取得平衡</li></ul></li></ul></li><li><strong>JRockit（BEA）</strong><ul><li>专注于服务器端应用，内部不包含解释器</li><li>世界上最快的JVM</li><li>BEA已被Oracle收购</li><li>有影响力的三大商用虚拟机之一</li></ul></li><li><strong>J9（IBM）</strong><ul><li>定位与HotSpot接近</li><li>有影响力的三大商用虚拟机之一</li><li>广泛用于IBM的各种Java产品</li></ul></li><li>Azul VM<ul><li>高性能虚拟机</li><li>前三个“高性能JVM”使用在通用硬件平台</li><li>Azul VM与特定硬件平台绑定、软硬件配合的专有虚拟机</li></ul></li><li>Liquid VM<ul><li>高性能虚拟机</li><li>不需要OS支持，它本身实现了一个专用OS的必要功能</li><li>直接运行在BEA的Hypervisor系统上，已暂停研发</li></ul></li><li>Apache Harmony<ul><li>其Java类库代码吸纳进了Android SDK</li></ul></li><li>Microsoft JVM<ul><li>在IE3浏览器支持Java Applets</li><li>已终止，换成HotSpot了</li></ul></li><li>Taobao JVM<ul><li>基于OpenJDK开发了自己的定制版本AlibabaJDK</li><li>对象能够在多个Java虚拟机进程中实现共享</li></ul></li><li>Dalvik VM<ul><li>安卓5.0之前支持的，非Java虚拟机，没有遵循Java虚拟机规范</li><li>使用基于寄存器的指令集结构</li></ul></li><li>Graal VM<ul><li>Oracle研发</li><li>跨语言全栈虚拟机（Java\C\C++\R\Python …..)</li><li>有可能取代HotSpot</li></ul></li></ol><h2 id="Java代码的执行流程"><a href="#Java代码的执行流程" class="headerlink" title="Java代码的执行流程"></a>Java代码的执行流程</h2><p>翻译字节码（解释器）：针对字节码指令进行解释执行，保证响应时间<br>JIT编译器：把字节码中的热点代码编译成机器指令并缓存，负责执行的性能。<br><img src="/../images/knowledge/jvm/Java%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="Java代码执行流程" title="Java代码执行流程" loading="lazy"></p><h1 id="字节码文件-x2F-类文件"><a href="#字节码文件-x2F-类文件" class="headerlink" title="字节码文件/类文件"></a>字节码文件/类文件</h1><h2 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h2><p>16进制，是紧凑的，一行16字节<br>JVM规范：</p><pre><code>ClassFile{    u4（前四个字节） 魔数(magic)    u2（接下来的两个字节） 小版本号    u2 主版本号    后边还有常量池、访问标志（公共私有之类的）、包名、类名、父类、接口、成员变量、方法、附加属性信息}</code></pre><h3 id="魔数-magic"><a href="#魔数-magic" class="headerlink" title="魔数(magic)"></a>魔数(magic)</h3><p>0~3字节，用来标识文件类型<br>java文件的魔数为cafebabe</p><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>4~7字节，表示类的版本</p><ul><li>4~5 小版本 Java中为00 00</li><li>6~7 主版本<br>00 34（52）表示Java8<br><em>由此可知0033是Java7</em></li></ul><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><ul><li>8<del>9字节表示常量池长度<br>如00 23（35）表示常量池有#1</del>#34项，注意#0项不计入，也没有值</li><li>查表</li></ul><h3 id="访问标识和继承信息"><a href="#访问标识和继承信息" class="headerlink" title="访问标识和继承信息"></a>访问标识和继承信息</h3><p>在常量池之后<br>前两个字节：访问标识<br>接下来两个字节：本类全限定名<br>接下来两个字节：父类全限定名<br>接下来两个字节：接口数量<br>（如果有接口的话后边跟着接口信息）</p><h3 id="变量（Field）信息"><a href="#变量（Field）信息" class="headerlink" title="变量（Field）信息"></a>变量（Field）信息</h3><p>在访问标识和继承信息之后<br>前两个字节：变量个数<br>字节码文件会用简洁的字符表示类型信息，比较特殊的几个：</p><pre><code>J  longL 类名 ;  类“类名”的引用Z  boolean [  一维数组</code></pre><h3 id="方法信息"><a href="#方法信息" class="headerlink" title="方法信息"></a>方法信息</h3><p>在变量信息之后<br>前两个字节：方法个数<br>方法结构：访问修饰符、名称、参数描述、方法属性数量、方法属性（比如Code属性就是方法要执行的代码）</p><h3 id="附加属性"><a href="#附加属性" class="headerlink" title="附加属性"></a>附加属性</h3><p>比如源文件名称啥的</p><h1 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h1><ul><li>工具：javap 对class文件进行反编译<br>  参数：-v 显示字节码和常量池的信息<pre><code>javap -v xxx.class</code></pre></li></ul><h2 id="♥运行流程"><a href="#♥运行流程" class="headerlink" title="♥运行流程"></a>♥运行流程</h2><p>原始java代码-&gt;编译后的字节码文件-&gt;常量池载入运行时常量池-&gt;方法字节码载入方法区-&gt;main线程开始运行，分配栈帧内存（LV表和操作数栈）-&gt;执行引擎开始执行字节码</p><blockquote><p>short（16位，-32768-32767）范围内的数据存储在字节码文件中，比short大的会存储在常量池中</p></blockquote><h3 id="字节码指令-1"><a href="#字节码指令-1" class="headerlink" title="字节码指令"></a>字节码指令</h3><ul><li><p>压入操作数栈</p><pre><code>bipush sipush ldc ldc2_w分别是将byte、short、int、long压入操作数栈注意：1. 一次压入四个字节，不够补齐，超出的话（long）压两次2. short范围内的数据和字节码在一块，超过的要去常量池中取   比如压入10为bipush 10，压入65535为ldc #3，然后去常量池找#3的数据压入3. 具体使用哪条指令按照数字在哪个范围内决定，比如int a = 100用的是bipush 1004. -1~5的常数赋值操作，直接用iconst_x，如int a = -1用的是iconst_m1， int a = 2用的是iconst_2</code></pre></li><li><p>将操作数栈顶数据弹出，存入局部变量表的slot x中</p><pre><code>istore_x如：istore_2 就是把数据存入slot 2中</code></pre></li><li><p>将局部变量表的slot x的值存入操作数栈中</p><pre><code>iload_x如：iload_2 就是把LV表slot 2中的数据加载到操作数栈中</code></pre></li><li><p>弹出操作数栈中的两个变量，计算后把结果压入栈</p><pre><code>iadd</code></pre></li><li><p>在<strong>局部变量slot x</strong>上进行自增n操作</p><pre><code>iinc x, n如iinc 1,1就是将LV表slot 1中的数字自增1i --其实就是iinc x,-1i += 10其实就是iinc x,10</code></pre><blockquote><p><strong>a++和++a的区别在于先执行iinc还是iload</strong><br>  a++是先执行iload</p></blockquote></li><li><p>从常量池中根据地址去堆中找到一个成员变量的引用，找到后把引用压入操作数栈</p><pre><code>getstatic 常量池序号如getstatic #4</code></pre></li><li><p>条件判断指令，指令后接着一个跳转行号作为参数</p><pre><code>与0比较：ifeq ifne iflt ifgt...与int比较：if_icmpeq if_icmplt... byte\char\short都是这个float：fcmplong：lcmpdouble：dcmp与引用比较：if_acmpeq ifacmne!= null：ifnonnull如： ifne 12 不等于0跳转到12行</code></pre><p>  跳转操作：</p><pre><code>goto 行号</code></pre></li><li><p>循环控制指令<br>  执行到最后利用<code>goto</code>跳转回循环的第一条字节码指令（do-while的话是跳转到循环体的第一条字节码指令，for和while是跳转到判断条件的第一条字节码指令，for的自增操作在跳转之前执行）</p></li><li><p>从常量池中根据地址去方法区找到需调用的方法，生成新的栈帧，传递参数，开始执行新栈帧中的字节码</p><pre><code>invokevirtual 常量池编号如invokevirtual #5</code></pre></li><li><p>完成方法调用，弹出栈帧，无返回参数，程序结束</p><pre><code>return</code></pre></li><li><p>❤经典面试题</p><pre><code>int x = 0;x = x ++;System.out.println(x); //结果为0</code></pre><p>  分析字节码指令可以看出，x = x++执行了下面几条指令</p><pre><code>假设x在LV表槽位1iload_1 //0被加载到操作数栈iinc 1,1 //LV表中++，结果为1istore_1 //赋值操作使得操作数栈中的0覆盖掉了LV表中的1 </code></pre></li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li>静态变量、代码块等赋值的代码会<strong>合并成一个特殊的方法</strong> <code> &lt;cint&gt;()V</code>进行初始化，<strong>是整个类的构造方法</strong></li><li>普通成员变量的赋值、类中的初始化代码块和构造方法<strong>会合并成</strong><code>&lt;init&gt;()V</code>，其中<strong>构造方法总是放在最后</strong>，是<strong>类中一个对象的构造方法</strong></li><li>指令<ul><li><code>aload_0</code> 加载this引用</li><li><code>putfield 成员变量名的常量池地址</code> 将操作数栈栈顶的值赋值给对应的成员变量<pre><code>举例：this.a = "s2"对应字节码如下：aload_0ldc #5 //&lt;-"s2" 将字符串s2加载到操作数栈中putfield #3 //-&gt;this.a 将字符串栈顶的s2赋值给this.a</code></pre></li></ul></li></ul><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><ul><li><p>构造方法、私有方法、标有final的方法(都是静态编译，提前确定的方法)</p><pre><code>invokespecial</code></pre><ul><li>新建对象:<ol><li>调用构造方法前，会有如下两条指令<pre><code>new 类名的常量池地址 //为对象分配内存，分配成功后把对象引用放入操作数栈dup //把栈顶的地址进行复制并压入栈</code></pre></li><li>之后根据栈顶引用调用<code>invokespecial</code>，执行构造方法（调用结束后将栈顶的引用会被清除掉）</li><li><code>astore_x</code>将对象引用存入到LV表的slot x中</li></ol></li></ul></li><li><p>普通public方法（因为可能会被重写，所以是动态绑定）</p><pre><code>invokevirtual</code></pre></li><li><p>静态方法(都是静态编译，提前确定的方法)</p><pre><code>invokestatic</code></pre></li></ul><pre><code>举例：假设类A的对象a的引用存在LV表的slot 1中，执行a.test1(); //test1()为普通公共方法a.test2(); //test2()为静态方法A.test2();字节码指令如下：//调用普通公共方法部分a.test1();//final等方法除了将invokevirtual换成invokespecial外，其他一样aload_1invokevirtual #4 //Method test1:()V//调用静态方法部分a.test2();aload_1pop //静态方法不需要对象调用，因此把对象直接pop掉//调用静态方法部分A.test2();invokestatic #5 //Method test2:()V</code></pre><h3 id="多态的原理-invokevirtual"><a href="#多态的原理-invokevirtual" class="headerlink" title="多态的原理 invokevirtual"></a>多态的原理 invokevirtual</h3><h4 id="HSDB工具"><a href="#HSDB工具" class="headerlink" title="HSDB工具"></a>HSDB工具</h4><p>用来查看类的信息<br>进入jdk安装目录，执行</p><pre><code>java -cp .lib/sa-jdi.jar sun.jvm.hotspot.HSDB</code></pre><p>根据进程ID连接相应进程</p><h4 id="虚方法表vtable"><a href="#虚方法表vtable" class="headerlink" title="虚方法表vtable"></a>虚方法表vtable</h4><ul><li>vtable在类加载中的链接阶段根据方法的重写规则生成</li><li>类中所有支持重写的方法的入口地址在类的vtable中</li><li>对象根据vtable确定调用哪个方法</li></ul><h4 id="多态查找过程"><a href="#多态查找过程" class="headerlink" title="多态查找过程"></a>多态查找过程</h4><p>当执行invokevirtual指令时，</p><ol><li>先通过栈帧中的对象引用找到对象</li><li>分析对象头，找到对象的实际Class</li><li>在Class中找到vtable</li><li>查vtable得到方法的具体地址</li><li>执行方法的字节码</li></ol><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul><li>若try中代码没有问题，会通过<code>goto</code>语句跳过异常处理</li><li>若try中代码有问题，需要借助Exception Table进行处理</li></ul><h4 id="异常表-Exception-Table"><a href="#异常表-Exception-Table" class="headerlink" title="异常表 Exception Table"></a>异常表 Exception Table</h4><ul><li><p>结构</p><ul><li>from：try代码块中起始位置（含头）</li><li>to：try代码块中终止位置（不含尾，指向goto出现的位置） </li><li>target：类型匹配成功会进入到target指向的行</li><li>type：类型匹配，发生的异常是否是声明的异常</li></ul></li><li><p>[from, to)是前闭后开的检测范围，一旦这个范围内的字节码执行出现异常，则通过type匹配异常类型，如果一致，进入target所指示的行号</p></li><li><p>多个catch块对应异常表中的多个条目，catch块中的变量可以在LV表中进行槽位复用（<em>因为作用域不相交</em>）</p></li><li><p>新语法multi-catch</p><pre><code>    try{        ...    }catch(异常1 | 异常2 | 异常3)</code></pre><p>  在异常表中会占3行，<strong>只有type不同</strong>，from、to、target均相同</p></li></ul><h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><ul><li>finally的字节码会分别在try块字节码、catch块字节码之后放一份</li><li>异常表至少有三项，除普通异常外，还有两项用来匹配try块和异常块中的任意异常或错误，跳转至try-catch块结束后的位置执行finally中的代码，如图所示:<br>  <img src="/../images/knowledge/jvm/finally%E5%AD%97%E8%8A%82%E7%A0%81.png" alt="finally字节码" title="finally字节码" loading="lazy"></li><li>❤面试题<ul><li>return写在try和finally，返回结果以finally为准，try中的return也会执行，但只执行到了return里面的expression（比如<code>return a+b;</code>只执行<code>a+b</code>)，expression首先存放在操作数栈顶，然后复制到LV表，并没有执行返回语句return<ul><li>如果在finally中写了return会吞掉异常字节码athrow，所以<strong>不要在finally中写return</strong></li></ul></li><li>finally对返回值的影响，以下代码返回10，finally的赋值操作没有对return产生影响，因为try中return时会先把返回值缓存起来<pre><code>    int i = 10;    try{        return i; //字节码执行到此时会把i的值存入LV表以固定返回值    }finally{        i = 20; //虽然将i改为20，但是ireturn从LV表里取值，LV表里的仍为10    }</code></pre></li></ul></li></ul><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><ul><li>方法级别的synchronized不会在字节码指令中有所体现，会在修饰符中出现<code>ACC_SYNCHRONIZED</code></li><li>代码块中的指令在<code>monitorenter</code>和<code>monitorexit</code>之间</li><li>锁对象会复制一份（<code>dup</code>操作），一个和<code>monitorenter</code>配合，一个和<code>monitorexit</code>配合</li></ul><h2 id="编译器处理（语法糖）"><a href="#编译器处理（语法糖）" class="headerlink" title="编译器处理（语法糖）"></a>编译器处理（语法糖）</h2><p>语法糖：java编译器把*.java源码编译成*.class字节码的过程中，自动生成和转换的一些代码</p><h3 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h3><p>如果没写无参构造器，<strong>编译器会自动生成无参构造器</strong></p><h3 id="自动拆装箱（JDK5及以后）"><a href="#自动拆装箱（JDK5及以后）" class="headerlink" title="自动拆装箱（JDK5及以后）"></a>自动拆装箱（JDK5及以后）</h3><ul><li>装箱：基本数据类型-&gt;包装类型 <pre><code>//JDK5之前// 注意：-128~127之间的整数会重用对象Integer x = Integer.valueOf(1);</code></pre></li><li>拆箱：包装类型-&gt;基本数据类型<pre><code>//JDK5之前int y = x.intValue;</code></pre></li></ul><h3 id="泛型集合取值（JDK5及以后）"><a href="#泛型集合取值（JDK5及以后）" class="headerlink" title="泛型集合取值（JDK5及以后）"></a>泛型集合取值（JDK5及以后）</h3><p>泛型擦除：泛型信息在编译为字节码以后就消失了，实际类型都当做Object处理：</p><pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(10); //编译后实际调用的是list.add(Object e)Integer x = list.get(0); //编译后实际调用的是Object obj = List.get(0);</code></pre><p>所以在取值后，编译器真正生成的字节码中，还要额外进行一个<strong>类型转换</strong>的操作：</p><pre><code>Integer x = (Integer)list.get(0);//类型转换字节码checkcast xxx</code></pre><p>擦除的是字节码上的泛型信息，<strong>LocalVariableTypeTable中仍然保留了方法参数泛型的信息</strong>，此部分泛型信息无法使用反射获取。<br>反射可以获取方法返回值和方法参数上的泛型信息：</p><pre><code>Method test = xx.class.getMethod("method name", 参数类型.class);Type[] types = test.getGenericParameterTypes();//获取泛型信息...</code></pre><h4 id="可变参数（JDK5及以后）"><a href="#可变参数（JDK5及以后）" class="headerlink" title="可变参数（JDK5及以后）"></a>可变参数（JDK5及以后）</h4><p>如：</p><pre><code>public static void foo(String... args){    ...}public static void main(String[] args){    foo("hello", "world");}</code></pre><p>编译后相当于</p><pre><code>public static void foo(String[] args){    ...}public static void main(String[] args){    foo(new String[]{"hello", "world"});}</code></pre><p>注意：调用无参的<code>foo()</code>会传一个空数组进去，而不会传null进去</p><h4 id="foreach（JDK5及以后）"><a href="#foreach（JDK5及以后）" class="headerlink" title="foreach（JDK5及以后）"></a>foreach（JDK5及以后）</h4><p>数组：</p><pre><code>int[] arrs = {1,2,3,4,5}; //语法糖1：数组赋初值的简化写法for(int arr : arrs){//语法糖2：foreach    ...}</code></pre><p>编译后相当于</p><pre><code>int[] arrs = new int[]{1,2,3,4,5};for(int i = 0; i &lt; arr.length; ++ i){    ...}</code></pre><p><strong>集合</strong>编译后会转换为对<strong>迭代器</strong>的调用：</p><pre><code>List&lt;Integer&gt; list = ...Iterator iter = list.iterator();while(it.hasNext()){    ...    Integer e = (Integer)iter.next();    ...}</code></pre><h4 id="switch字符串（JDK7及以后）"><a href="#switch字符串（JDK7及以后）" class="headerlink" title="switch字符串（JDK7及以后）"></a>switch字符串（JDK7及以后）</h4><p>JDK7之后switch可以作用于字符串和枚举类：</p><pre><code>switch(str){    case "hello":         ...hello的操作...        break;    case "world":         ...word的操作...        break;}</code></pre><p>编译后变成了两个switch，匹配改变为<strong>匹配字符串的hashcode以及字符串本身</strong>：</p><pre><code>byte x = -1;switch(str.hashCode()){    case 99162322: //hello的hashCode        if(str.equals("hello")){            x = 0;        }        break;    case 113318802: //world的hashCode        if(str.equals("world")){            x = 1;        }        break;    default:        switch(x){            case 0:                ...hello的操作...            case 1:                ...word的操作...        }}</code></pre><h4 id="switch枚举类（JDK7及以后）"><a href="#switch枚举类（JDK7及以后）" class="headerlink" title="switch枚举类（JDK7及以后）"></a>switch枚举类（JDK7及以后）</h4><p>定义一个静态内部合成类（仅jvm使用，对我们不可见）用来映射枚举的ordinal与数组元素的关系。switch针对这个数组元素进行匹配。</p><blockquote><p>枚举的ordinal表示枚举对象的序号，从0开始。</p></blockquote><h4 id="枚举类（JDK7及以后）"><a href="#枚举类（JDK7及以后）" class="headerlink" title="枚举类（JDK7及以后）"></a>枚举类（JDK7及以后）</h4><p>编译后会生成一个final类<br><img src="/../images/knowledge/jvm/%E6%9E%9A%E4%B8%BE%E7%B1%BB.png" alt="&quot;转换后枚举类&quot;" title="转换后枚举类" loading="lazy"></p><h1 id="类加载器子系统"><a href="#类加载器子系统" class="headerlink" title="类加载器子系统"></a>类加载器子系统</h1><p><img src="/../images/knowledge/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84.png" alt="类加载器整体结构" title="类加载器整体结构" loading="lazy"></p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>负责从文件系统或网络中加载Class文件，class文件在文件开头有特定的文件标识</li><li>只负责加载，<strong>是否能够运行由执行引擎决定</strong></li><li>加载的<strong>类信息存放于一块称为方法区</strong>的内存空间。方法区还存放运行时常量池信息。</li></ul><h2 id="❤加载过程"><a href="#❤加载过程" class="headerlink" title="❤加载过程"></a>❤加载过程</h2><p>加载-&gt;链接（验证-&gt;准备-&gt;解析）-&gt;初始化<br><em>ps:此部分面试时应说清楚每个阶段的过程</em></p><h3 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h3><ol><li>通过一个类的全限定名获取定义<strong>此类的二进制字节流</strong></li><li>将这个字节流所代表的<strong>静态存储结构转化为方法区的运行时数据结构</strong></li><li><strong>在内存中生成一个代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口</li></ol><h3 id="链接（Linking"><a href="#链接（Linking" class="headerlink" title="链接（Linking)"></a>链接（Linking)</h3><ol><li>验证（verify）<ul><li>目的：确保Class文件字节流中包含信息符合JVM要求，保证被加载类正确性，不危害JVM的自身安全<br> <em>如：java的class文件开头都是cafe babe</em></li></ul></li><li>准备（prepare）<ul><li><strong>为静态类变量（static定义的）分配一个默认初始值</strong><br>  这里<strong>不包含常量</strong>（final修饰的static），final在编译时就会分配了，准备阶段会显式初始化<br>  <strong>不会为实例变量分配初始化</strong></li></ul></li><li>解析（resolve）<ul><li>将常量池中的符号引用转换为直接引用</li><li>在方法区中创建虚方法表</li><li>符号引用：一组符号来描述所引用的目标</li><li>直接引用：直接指向目标的指针<blockquote><p><strong>虚方法表</strong>：为了提高性能，JVM在类的方法区建立一个虚方法表（非虚方法不需要）来实现。使用索引表代替以上查找过程。每个类中都有一个虚方法表，存放各个方法的实际入口。虚方法表会在类加载的链接阶段（具体在解析阶段）被创建并开始初始化，类的变量初始值准备完成后，JVM会把该类的方发表也初始化完毕。</p></blockquote></li></ul></li></ol><h3 id="初始化（Initialization）"><a href="#初始化（Initialization）" class="headerlink" title="初始化（Initialization）"></a>初始化（Initialization）</h3><ol><li>初始化阶段就是执行类构造器方法<code>&lt;cinit&gt;()</code>的过程  <ul><li><code>&lt;cinit&gt;()</code>不需要自己定义，是java编译器自动收集类中的所有<strong>静态类变量的赋值动作和静态代码块中的语句</strong>合并起来<br> ps:要是没有这两块内容，就不会生成<code>&lt;cinit&gt;()</code></li><li><code>&lt;cinit&gt;()</code>中的指令按语句在源文件中出现的顺序执行</li><li>若有父类，会先执行父类的<code>&lt;cinit&gt;()</code>方法</li><li>虚拟机必须保证一个类的<code>&lt;cinit&gt;()</code>方法在多线程下被<strong>同步加锁，保证方法只执行一次</strong></li></ul></li><li>任何一个类声明以后，内部至少存在一个类的构造器，在此阶段表现为<code>&lt;init&gt;</code>方法</li></ol><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="❤分类"><a href="#❤分类" class="headerlink" title="❤分类"></a>❤分类</h3><ul><li>引导类加载器  </li><li>自定义类加载器<br>所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器<ul><li>扩展类加载器<br>  上层为引导类加载器，在java中获取不到引导类加载器  </li><li>系统类加载器<br>  上层为扩展类加载器</li><li>用户自定义类加载器<br>  默认使用系统类加载器进行加载</li></ul></li></ul><h3 id="❤引导类加载器"><a href="#❤引导类加载器" class="headerlink" title="❤引导类加载器"></a>❤引导类加载器</h3><ul><li>C/C++编写，嵌套在JVM内部，在java中获取该加载器会返回null</li><li><strong>Java的核心类库都是使用引导类加载器进行加载的</strong></li><li>没有父类加载器</li><li>加载扩展类加载器和应用程序类加载器（系统加载器），并指定为他们的父类加载器</li></ul><h3 id="❤扩展类加载器"><a href="#❤扩展类加载器" class="headerlink" title="❤扩展类加载器"></a>❤扩展类加载器</h3><ul><li>Java语言编写，ExtClassLoader实现</li><li>派生于ClassLoader</li><li>父类加载器为启动类加载器</li><li>加载jre/lib/ext子目录下的类库。用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</li></ul><h3 id="❤应用程序类加载器（系统类加载器）"><a href="#❤应用程序类加载器（系统类加载器）" class="headerlink" title="❤应用程序类加载器（系统类加载器）"></a>❤应用程序类加载器（系统类加载器）</h3><ul><li>Java语言编写，APPClassLoader实现</li><li>派生于ClassLoader</li><li>父类加载器为扩展类加载器</li><li>加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li><strong>程序中默认的类加载器</strong></li></ul><h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><ul><li>为什么使用？  <ul><li>隔离加载类（避免引入了不同中间件后类冲突）（不同类加载器加载的类不能相互访问）</li><li>修改类的加载方式</li><li>扩展加载源</li><li>防止源码泄露</li></ul></li><li>步骤<ol><li>继承抽象类ClassLoader</li><li>jdk1.2后不再重写loadClass()，而是建议把自定义的类加载逻辑写在findClass(String fileName)中</li><li>没有过于复杂的需求（加解密之类的）可以直接继承URLClassLoader</li></ol></li></ul><h3 id="ClassLoader类"><a href="#ClassLoader类" class="headerlink" title="ClassLoader类"></a>ClassLoader类</h3><ul><li>获取<ul><li>获取当前类的加载器：<br>   Class.forName(“当前类完整包名”).getClassLoader()</li><li>获取当前线程上下文的类加载器：<br>  Thread.currentThread().getContextClassLoader()</li><li>ClassLoader.getSystemClassLoader()</li></ul></li></ul><h3 id="❤双亲委派机制"><a href="#❤双亲委派机制" class="headerlink" title="❤双亲委派机制"></a>❤双亲委派机制</h3><p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且<strong>加载某个类的class文件时，Java虚拟机采用的是双亲委派模式</strong>，即把请求交由父类处理，它是一种任务委派模式。 </p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ol><li>一个类加载器收到了类加载请求，会先把这个请求委托给父类的加载器去执行，依次递归，请求最终将到达顶层的启动类加载器</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载<br><img src="https://jvm-lcc.oss-cn-beijing.aliyuncs.com/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F.png" alt="双亲委派模式" title="双亲委派模式" loading="lazy"></li></ol><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心API被随意篡改  <ul><li><p>比如自己建一个java.lang包，里面写String，该类会被忽略，因为该机制会在引导类加载器中加载正确的String<br>  <img src="/../images/knowledge/jvm/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F%E5%AE%89%E5%85%A8%E6%8A%A5%E9%94%991.png" alt="双亲委派模式安全报错1" title="双亲委派模式安全报错1" loading="lazy"></p></li><li><p>又比如在java.lang包中写自定义类，运行会直接报错<br>  <img src="/../images/knowledge/jvm/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F%E5%AE%89%E5%85%A8%E6%8A%A5%E9%94%992.png" alt="双亲委派模式安全报错2" title="双亲委派模式安全报错2" loading="lazy"></p></li></ul></li></ul><h4 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h4><p>自定义string类，但是在加载自定义string类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件(rt.jar包中java \lang \string.class)，报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="在JVM中两个class对象是否为同一个类的两个必要条件"><a href="#在JVM中两个class对象是否为同一个类的两个必要条件" class="headerlink" title="在JVM中两个class对象是否为同一个类的两个必要条件"></a>在JVM中两个class对象是否为同一个类的两个必要条件</h4><ul><li>类的完整类名必须一致，包括包名</li><li>加载这个类的类加载器必须相同</li></ul><h4 id="对类加载器的引用"><a href="#对类加载器的引用" class="headerlink" title="对类加载器的引用"></a>对类加载器的引用</h4><ul><li>如果一个类是由用户类加载器加载的，JVM会将<strong>用户类加载器</strong>（<em>启动类加载器以外的所有加载器</em>）的一个引用作为类型信息的一部分保存在方法区中  </li><li>当解析一个类型到另一个类型的引用时，JVM需要保证这两个类的加载器是相同的，因为不同类加载器加载的类之间是无法直接交互的。<blockquote><p><strong>问题</strong>：我们能在自己写的类中访问到String对象，但String是由引导类加载器加载的，显然和我们自己的类用的不是同一个加载器，这不就说明不同类加载器加载的类之间是可以直接交互吗？<br>  <strong>答</strong>：否，加载器还有<strong>定义类加载器</strong>和<strong>初始类加载器</strong>两种，对于String类来说，它是通过我们自己写的类的加载器（即系统类加载器）进行加载，系统类加载器将它一路向上委托，最终由引导类加载器对它进行加载。因此引导类加载器是它的定义类加载器，委托路上的所有类加载器（系统类加载器、扩展类加载器、引导类加载器）都是它的初始类加载器，String类在这些类加载器的命名空间中均有出现，因此，我们能在自己写的类中访问到String对象。<br>  <strong>参考</strong>：<a href="https://bbs.csdn.net/topics/300146816">https://bbs.csdn.net/topics/300146816</a></p></blockquote></li></ul><h4 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h4><p>区别在于：会不会导致<strong>类的初始化</strong>（注意是<code>&lt;cint&gt;</code>，不是对象的初始化<code>&lt;init&gt;</code>）<br>主动使用：</p><ul><li>创建类实例</li><li>访问类或类或接口的静态变量,或者对该静态变量赋值</li><li>调用类的静态方法</li><li>初始化子类</li><li>反射</li><li>JVM启动时被标为启动类的类（如main）</li><li>JDK 7开始提供的动态语言支持</li></ul><p>被动使用：除上面之外的其他使用属于被动使用</p><ul><li>通过子类访问父类的静态变量，子类没有被初始化</li><li>通过数组定义类引用类，为类的被动使用，不会触发类的初始化<pre><code>MyClass[] arr = new MyClass[10];</code></pre></li><li>调用类的静态常量，常量在编译阶段会存入调用方法所在的类的常量池中，本质上没有直接引用到定义常量的类<br>  特殊情况：<pre><code>static final String s = UUID.randomUUID().toString(); </code></pre>  该情况类会初始化，因为UUID.randomUUID().toString()这个方法，是运行期确认的，所以，这不是被动使用</li></ul><blockquote><p>参考：<a href="https://www.cnblogs.com/billmiao/p/9872226.html">https://www.cnblogs.com/billmiao/p/9872226.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文笔记】Blockchain-Based Incentives for Secure and Collaborative Data Sharing in Multiple Clouds</title>
      <link href="/2022/08/29/0829-Blockchain-Based-Incentives/"/>
      <url>/2022/08/29/0829-Blockchain-Based-Incentives/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>设计一种结合区块链和Shapley值的数据共享方案，可以实现安全和协作共享。</p><h3 id="设计挑战"><a href="#设计挑战" class="headerlink" title="设计挑战"></a>设计挑战</h3><ol><li>隐私保护与数据安全问题。</li><li>动态收入分配。</li></ol><h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h3><ol><li>提出了一种新的多云数据共享业务模型，通过联盟区块链授权各种参与者，并保证数据隐私的安全。</li><li>利用Shapley值为多个云中的数据共享构建一个动态和公平的激励方案。开发了三个复杂的收入分配模型，并考虑了矿工参与合作的情况。</li></ol><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li>场景：医疗机构作为数据所有者与第三方和患者共享医疗数据</li><li>问题：<ol><li>多名参与者之间的信任问题以及公平有效的数据共享</li><li>数据隐私问题，参与者可能会请求一些不完全公开的数据</li><li>多参与者之间的公平激励机制，确保数据所有者能提供可信、可靠的数据。</li></ol></li><li>假设：只有当诊断处理中心和医院之间的收入公平分配时，才会提供正确的检查数据或诊断报告，因此需要设计公平的激励机制，实现收入公平分配。</li></ul><h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><ul><li>满足条件：<ol><li>基于云服务提供数据共享平台</li><li>通过共识和信任实现资源共享：区块链</li><li>实现多参与者协作</li><li>确保参与者的合理权限：联盟区块链</li><li>为达成共享框架中的可靠数据共享提供激励机制：利用Shapley值解决联盟成员的收入分配问题</li></ol></li></ul><blockquote><p>Shapley值：通过考虑联盟区块链中各成员对共享数据的贡献程度来计算边界贡献值，从而将收入公平分配给联合体成员，经常用于协作和共享场景</p></blockquote><h3 id="Shapley值"><a href="#Shapley值" class="headerlink" title="Shapley值"></a>Shapley值</h3><p><img src="/../images/paper/Shapley/equation1.png" alt="公式1" title="公式1" loading="lazy"><br>(1)表示一个所有参与者产生的所有收入 = 所有联盟中参与者的Shapley值之和。<br>参与者i的边缘收入为：<br><img src="/../images/paper/Shapley/marginal.png" alt="边缘收入" title="边缘收入" loading="lazy"><br>收入随着一组参与者以特定顺序加入联盟而动态变化，因此参与者i的Shapley值由下式计算：<br><img src="/../images/paper/Shapley/equation2.png" alt="公式2" title="公式2" loading="lazy"><br>结合(1)(2)，可得：<br><img src="/../images/paper/Shapley/equation3.png" alt="公式3" title="公式3" loading="lazy"><br>可以看出，Shapley价值方案通过计算参与者<strong>参与联盟时的收入增量</strong>来衡量每个参与者的贡献。</p><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><h3 id="业务模型"><a href="#业务模型" class="headerlink" title="业务模型"></a>业务模型</h3><p><img src="/../images/paper/Shapley/fig1.png" alt="业务模型" title="业务模型" loading="lazy">   </p><ul><li>第三方：多云数据的用户，基于自身业务提出对共享数据的请求。</li><li>数据所有者：掌握不同种数据。当第三方发布请求，拥有需求数据的所有者会被激励并参与可靠数据共享。随着用户为特定类型的服务付费，只有提供相关数据的人才能作为服务提供商获得报酬。  </li><li>区块链网络：主要作用是访问控制。</li><li>智能合约：管理资金流并决定付款条件。</li></ul><h3 id="可靠协作模型"><a href="#可靠协作模型" class="headerlink" title="可靠协作模型"></a>可靠协作模型</h3><p><img src="/../images/paper/Shapley/fig2.png" alt="可靠协作模型" title="可靠协作模型" loading="lazy">  </p><ul><li>参与者类型：第三方$T$、矿工$M$和数据所有者$H$  </li><li>规定所有第三方提供的服务集合R=所有多云数据集合D，即<strong>所有需求都能被共享数据满足</strong>。假设某第三方的一个需求为r，某数据所有者拥有数据d，r=d代表该数据所有者向该第三方分享了d这种数据。</li></ul><h3 id="Concerns"><a href="#Concerns" class="headerlink" title="Concerns"></a>Concerns</h3><ol><li>系统总收入：<br><img src="/../images/paper/Shapley/equation4.png" alt="公式4" title="公式4" loading="lazy"><br>$x_i^r$表示第三方$T_i$在一段时间内提供服务$r$的次数。<br>假设条件：相同的业务中所有第三方获得的收入相同。因此用户请求每种服务的次数决定第三方的收入。<br>可以提供服务$r$的数据所有者数量为$h_r$，可由(5)得出:<br><img src="/../images/paper/Shapley/equation5.png" alt="公式5" title="公式5" loading="lazy"> </li><li>矿工<br>负责记录联盟链中的数据记录和传播。根据他们记录事务的比例来分配收入。</li><li>不同角色在数据共享中贡献计算<ul><li>数据所有者<br>  在第三方中实现预测模型的训练，数据所有者的数据质量由第三方分析并衡量，数据质量由F1值来表示。</li><li>第三方<br>  有影响力已经提高更大的贡献的第三方收入多。</li><li>矿工<br>  挖矿能力越强收入越多。</li></ul></li></ol><h2 id="收入分配模型"><a href="#收入分配模型" class="headerlink" title="收入分配模型"></a>收入分配模型</h2><h3 id="数据所有者之间的收入分配"><a href="#数据所有者之间的收入分配" class="headerlink" title="数据所有者之间的收入分配"></a>数据所有者之间的收入分配</h3><p>假设：所有数据所有者都有同种类型的数据，即所有数据所有者都只提供服务$r$。<strong>此时，收入分配只需考虑各个所有者的贡献，即他们分享的数据的影响因子</strong>。假设该模型中的所有数据所有者共享具有正影响因素的多个云数据，因此每个参与者的Shapley值是合法的。<br>首先，通过训练任意分享数据的子集可以得到预测模型，该模型使用F1 score来评估数据所有者的贡献。对于系统$(N, v)$，Shapley值和F1 score的关系为：<br><img src="/../images/paper/Shapley/equation6.png" alt="公式6" title="公式6" loading="lazy"><br>类似于公式(2)，可以将参与者的贡献量化为F1 score，即：$\Delta_i(F1,s)=F1(s\cup{i})-F1(s)$<br><strong>引理1（数据所有者的Shapley值）</strong>：考虑数据所有者$H$都共享同一种多云数据。对于数据所有者们，令$S_H^i$为不包含数据所有者$H_i$的其他数据所有者集合，根据数据所有者对F1分数的边际贡献，Shapley价值收入定义如下：<br><img src="/../images/paper/Shapley/equation7_8.png" alt="公式7-8" title="公式7-8" loading="lazy"><br>每个数据所有者的Shapley值可以是他获得总收入的一个百分比（比如总收入的10%归他）。由于F1 score不同，因此不同数据所有者的Shapley值各不相同，但是他们的总和=总收入。</p><h3 id="SSDG模型"><a href="#SSDG模型" class="headerlink" title="SSDG模型"></a>SSDG模型</h3><h3 id="SSTG模型"><a href="#SSTG模型" class="headerlink" title="SSTG模型"></a>SSTG模型</h3><h3 id="MS模型"><a href="#MS模型" class="headerlink" title="MS模型"></a>MS模型</h3><blockquote><p>由于该文和博主研究方向相差太远，因此断更，详见原文。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链, 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>truffle初始化程序出现错误</title>
      <link href="/2022/07/28/truffle-install-error/"/>
      <url>/2022/07/28/truffle-install-error/</url>
      
        <content type="html"><![CDATA[<h1 id="truffle初始化程序出现错误"><a href="#truffle初始化程序出现错误" class="headerlink" title="truffle初始化程序出现错误"></a>truffle初始化程序出现错误</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>执行<code>truffle unbox pet-shop</code>时报错：</p><pre><code>Error: getaddrinfo ENOENT raw.githubusercontent.com at GetAddrInfoReqWrap.onlookup [as oncomplete] (node:dns:71:26)</code></pre><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>打开C:\Windows\System32\drivers\etc中的host文件，写入：</p><pre><code>199.232.68.133 raw.githubusercontent.com</code></pre><p>搞定~</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链; 科研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链学习网站收集</title>
      <link href="/2022/07/27/blockchaindoc/"/>
      <url>/2022/07/27/blockchaindoc/</url>
      
        <content type="html"><![CDATA[<h1 id="区块链学习网站收集"><a href="#区块链学习网站收集" class="headerlink" title="区块链学习网站收集"></a>区块链学习网站收集</h1><h2 id="公有链"><a href="#公有链" class="headerlink" title="公有链"></a>公有链</h2><h3 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h3><p>以太坊官网：<a href="https://ethereum.org/">https://ethereum.org/</a><br>以太坊Overview：<a href="https://trufflesuite.com/guides/ethereum-overview/">https://trufflesuite.com/guides/ethereum-overview/</a></p><h3 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h3><p>Solidity语言：<a href="https://docs.soliditylang.org/en/v0.5.0/">https://docs.soliditylang.org/en/v0.5.0/</a></p><h3 id="Truffle框架"><a href="#Truffle框架" class="headerlink" title="Truffle框架"></a>Truffle框架</h3><p>Truffle官网：<a href="https://trufflesuite.com/">https://trufflesuite.com/</a><br>Truffle入门教程：<a href="https://trufflesuite.com/tutorial/">https://trufflesuite.com/tutorial/</a></p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【力扣69】 x 的平方根</title>
      <link href="/2022/07/24/leetcode69/"/>
      <url>/2022/07/24/leetcode69/</url>
      
        <content type="html"><![CDATA[<h2 id="问题详解"><a href="#问题详解" class="headerlink" title="问题详解"></a>问题详解</h2><p><a href="https://leetcode.cn/problems/sqrtx/">题目链接</a><br>两种方案，二分查找/牛顿迭代法</p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>局限性比较大，如要求返回类型是浮点数时不适用。</p><h3 id="❤牛顿迭代法"><a href="#❤牛顿迭代法" class="headerlink" title="❤牛顿迭代法"></a>❤牛顿迭代法</h3><p>通过迭代来向目标值进行逼近，详解如下图：<br><img src="/../images/leetcode/newton.jpg" alt="牛顿迭代法" title="牛顿迭代法" loading="lazy"><br>重点：  </p><ul><li><code>x1 = (x + a / x) / 2</code></li><li>用<code>r &gt; x / r</code>代替<code>r^2 &gt; x</code>可以防止溢出</li><li><code>long r = x;</code><br>  当<code>r=2^31-1</code>时，<code>r + x / r</code>会溢出哦！</li></ul><pre><code>class Solution {    public int mySqrt(int x) {        if (x &lt;= 1) return x;        long r = x;        while (r &gt; x / r) { // r^2 &gt; x 防止溢出            r = (r + x / r) / 2;        }        return (int)r;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ASP.Net报错】localhost未响应</title>
      <link href="/2022/06/08/localhost-not-responding/"/>
      <url>/2022/06/08/localhost-not-responding/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>第一次运行ASP.Net项目，运行成功后打开浏览器访问，显示<strong>localhost花了太长时间进行响应</strong>。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><ul><li>首先ping了localhost，发现没什么问题，进一步怀疑是端口问题。  </li><li>之后<code>netstat -an</code>查看端口，发现我要访问的端口状态是LISTENING，也没啥问题。</li><li>最后查了防火墙的入站规则，发现没有记录，所以访问不到该端口。</li></ul><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>防火墙-&gt;高级设置-&gt;入站规则-&gt;新建规则-&gt;规则类型选端口-&gt;协议和端口选择TCP协议和要访问的端口-&gt;随便取个名称，搞定~</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASP.Net </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
